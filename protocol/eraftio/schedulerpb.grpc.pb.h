// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: schedulerpb.proto
#ifndef GRPC_schedulerpb_2eproto__INCLUDED
#define GRPC_schedulerpb_2eproto__INCLUDED

#include "schedulerpb.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace grpc_impl {
class CompletionQueue;
class ServerCompletionQueue;
class ServerContext;
}  // namespace grpc_impl

namespace grpc {
namespace experimental {
template <typename RequestT, typename ResponseT>
class MessageAllocator;
}  // namespace experimental
}  // namespace grpc

namespace schedulerpb {

class Scheduler final {
 public:
  static constexpr char const* service_full_name() {
    return "schedulerpb.Scheduler";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    // GetMembers get the member list of this cluster. It does not require
    // the cluster_id in request matchs the id of this cluster.
    virtual ::grpc::Status GetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::schedulerpb::GetMembersResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetMembersResponse>> AsyncGetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetMembersResponse>>(AsyncGetMembersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetMembersResponse>> PrepareAsyncGetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetMembersResponse>>(PrepareAsyncGetMembersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>> Tso(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>>(TsoRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>> AsyncTso(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>>(AsyncTsoRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>> PrepareAsyncTso(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>>(PrepareAsyncTsoRaw(context, cq));
    }
    virtual ::grpc::Status Bootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::schedulerpb::BootstrapResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::BootstrapResponse>> AsyncBootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::BootstrapResponse>>(AsyncBootstrapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::BootstrapResponse>> PrepareAsyncBootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::BootstrapResponse>>(PrepareAsyncBootstrapRaw(context, request, cq));
    }
    virtual ::grpc::Status IsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::schedulerpb::IsBootstrappedResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::IsBootstrappedResponse>> AsyncIsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::IsBootstrappedResponse>>(AsyncIsBootstrappedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::IsBootstrappedResponse>> PrepareAsyncIsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::IsBootstrappedResponse>>(PrepareAsyncIsBootstrappedRaw(context, request, cq));
    }
    virtual ::grpc::Status AllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::schedulerpb::AllocIDResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::AllocIDResponse>> AsyncAllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::AllocIDResponse>>(AsyncAllocIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::AllocIDResponse>> PrepareAsyncAllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::AllocIDResponse>>(PrepareAsyncAllocIDRaw(context, request, cq));
    }
    virtual ::grpc::Status GetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::schedulerpb::GetStoreResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetStoreResponse>> AsyncGetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetStoreResponse>>(AsyncGetStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetStoreResponse>> PrepareAsyncGetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetStoreResponse>>(PrepareAsyncGetStoreRaw(context, request, cq));
    }
    virtual ::grpc::Status PutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::schedulerpb::PutStoreResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::PutStoreResponse>> AsyncPutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::PutStoreResponse>>(AsyncPutStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::PutStoreResponse>> PrepareAsyncPutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::PutStoreResponse>>(PrepareAsyncPutStoreRaw(context, request, cq));
    }
    virtual ::grpc::Status GetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::schedulerpb::GetAllStoresResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetAllStoresResponse>> AsyncGetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetAllStoresResponse>>(AsyncGetAllStoresRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetAllStoresResponse>> PrepareAsyncGetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetAllStoresResponse>>(PrepareAsyncGetAllStoresRaw(context, request, cq));
    }
    virtual ::grpc::Status StoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::schedulerpb::StoreHeartbeatResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::StoreHeartbeatResponse>> AsyncStoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::StoreHeartbeatResponse>>(AsyncStoreHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::StoreHeartbeatResponse>> PrepareAsyncStoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::StoreHeartbeatResponse>>(PrepareAsyncStoreHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>> RegionHeartbeat(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriterInterface< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>>(RegionHeartbeatRaw(context));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>> AsyncRegionHeartbeat(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>>(AsyncRegionHeartbeatRaw(context, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>> PrepareAsyncRegionHeartbeat(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriterInterface< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>>(PrepareAsyncRegionHeartbeatRaw(context, cq));
    }
    virtual ::grpc::Status GetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::schedulerpb::GetRegionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>> AsyncGetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>>(AsyncGetRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>> PrepareAsyncGetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>>(PrepareAsyncGetRegionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::schedulerpb::GetRegionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>> AsyncGetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>>(AsyncGetPrevRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>> PrepareAsyncGetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>>(PrepareAsyncGetPrevRegionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::schedulerpb::GetRegionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>> AsyncGetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>>(AsyncGetRegionByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>> PrepareAsyncGetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>>(PrepareAsyncGetRegionByIDRaw(context, request, cq));
    }
    virtual ::grpc::Status ScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::schedulerpb::ScanRegionsResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::ScanRegionsResponse>> AsyncScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::ScanRegionsResponse>>(AsyncScanRegionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::ScanRegionsResponse>> PrepareAsyncScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::ScanRegionsResponse>>(PrepareAsyncScanRegionsRaw(context, request, cq));
    }
    virtual ::grpc::Status AskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::schedulerpb::AskSplitResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::AskSplitResponse>> AsyncAskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::AskSplitResponse>>(AsyncAskSplitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::AskSplitResponse>> PrepareAsyncAskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::AskSplitResponse>>(PrepareAsyncAskSplitRaw(context, request, cq));
    }
    virtual ::grpc::Status GetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::schedulerpb::GetClusterConfigResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetClusterConfigResponse>> AsyncGetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetClusterConfigResponse>>(AsyncGetClusterConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetClusterConfigResponse>> PrepareAsyncGetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetClusterConfigResponse>>(PrepareAsyncGetClusterConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status PutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::schedulerpb::PutClusterConfigResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::PutClusterConfigResponse>> AsyncPutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::PutClusterConfigResponse>>(AsyncPutClusterConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::PutClusterConfigResponse>> PrepareAsyncPutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::PutClusterConfigResponse>>(PrepareAsyncPutClusterConfigRaw(context, request, cq));
    }
    virtual ::grpc::Status ScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::schedulerpb::ScatterRegionResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::ScatterRegionResponse>> AsyncScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::ScatterRegionResponse>>(AsyncScatterRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::ScatterRegionResponse>> PrepareAsyncScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::ScatterRegionResponse>>(PrepareAsyncScatterRegionRaw(context, request, cq));
    }
    virtual ::grpc::Status GetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::schedulerpb::GetGCSafePointResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetGCSafePointResponse>> AsyncGetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetGCSafePointResponse>>(AsyncGetGCSafePointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetGCSafePointResponse>> PrepareAsyncGetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetGCSafePointResponse>>(PrepareAsyncGetGCSafePointRaw(context, request, cq));
    }
    virtual ::grpc::Status UpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::schedulerpb::UpdateGCSafePointResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::UpdateGCSafePointResponse>> AsyncUpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::UpdateGCSafePointResponse>>(AsyncUpdateGCSafePointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::UpdateGCSafePointResponse>> PrepareAsyncUpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::UpdateGCSafePointResponse>>(PrepareAsyncUpdateGCSafePointRaw(context, request, cq));
    }
    virtual ::grpc::Status GetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::schedulerpb::GetOperatorResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetOperatorResponse>> AsyncGetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetOperatorResponse>>(AsyncGetOperatorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetOperatorResponse>> PrepareAsyncGetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetOperatorResponse>>(PrepareAsyncGetOperatorRaw(context, request, cq));
    }
    class experimental_async_interface {
     public:
      virtual ~experimental_async_interface() {}
      // GetMembers get the member list of this cluster. It does not require
      // the cluster_id in request matchs the id of this cluster.
      virtual void GetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest* request, ::schedulerpb::GetMembersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMembers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetMembersResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest* request, ::schedulerpb::GetMembersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetMembers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetMembersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Tso(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::schedulerpb::TsoRequest,::schedulerpb::TsoResponse>* reactor) = 0;
      virtual void Bootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest* request, ::schedulerpb::BootstrapResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Bootstrap(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::BootstrapResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Bootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest* request, ::schedulerpb::BootstrapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void Bootstrap(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::BootstrapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void IsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest* request, ::schedulerpb::IsBootstrappedResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsBootstrapped(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::IsBootstrappedResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void IsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest* request, ::schedulerpb::IsBootstrappedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void IsBootstrapped(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::IsBootstrappedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest* request, ::schedulerpb::AllocIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AllocID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::AllocIDResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest* request, ::schedulerpb::AllocIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AllocID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::AllocIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest* request, ::schedulerpb::GetStoreResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStore(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetStoreResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest* request, ::schedulerpb::GetStoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetStore(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetStoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void PutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest* request, ::schedulerpb::PutStoreResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PutStore(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::PutStoreResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest* request, ::schedulerpb::PutStoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void PutStore(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::PutStoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest* request, ::schedulerpb::GetAllStoresResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAllStores(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetAllStoresResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest* request, ::schedulerpb::GetAllStoresResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetAllStores(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetAllStoresResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest* request, ::schedulerpb::StoreHeartbeatResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreHeartbeat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::StoreHeartbeatResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void StoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest* request, ::schedulerpb::StoreHeartbeatResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void StoreHeartbeat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::StoreHeartbeatResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void RegionHeartbeat(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::schedulerpb::RegionHeartbeatRequest,::schedulerpb::RegionHeartbeatResponse>* reactor) = 0;
      virtual void GetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPrevRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetPrevRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRegionByID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetRegionByID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest* request, ::schedulerpb::ScanRegionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ScanRegions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::ScanRegionsResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest* request, ::schedulerpb::ScanRegionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ScanRegions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::ScanRegionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest* request, ::schedulerpb::AskSplitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AskSplit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::AskSplitResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void AskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest* request, ::schedulerpb::AskSplitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void AskSplit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::AskSplitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest* request, ::schedulerpb::GetClusterConfigResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetClusterConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetClusterConfigResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest* request, ::schedulerpb::GetClusterConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetClusterConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetClusterConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void PutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest* request, ::schedulerpb::PutClusterConfigResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PutClusterConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::PutClusterConfigResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void PutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest* request, ::schedulerpb::PutClusterConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void PutClusterConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::PutClusterConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest* request, ::schedulerpb::ScatterRegionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ScatterRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::ScatterRegionResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest* request, ::schedulerpb::ScatterRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void ScatterRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::ScatterRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest* request, ::schedulerpb::GetGCSafePointResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGCSafePoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetGCSafePointResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest* request, ::schedulerpb::GetGCSafePointResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetGCSafePoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetGCSafePointResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest* request, ::schedulerpb::UpdateGCSafePointResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateGCSafePoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::UpdateGCSafePointResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest* request, ::schedulerpb::UpdateGCSafePointResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void UpdateGCSafePoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::UpdateGCSafePointResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest* request, ::schedulerpb::GetOperatorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetOperator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetOperatorResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest* request, ::schedulerpb::GetOperatorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
      virtual void GetOperator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetOperatorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) = 0;
    };
    virtual class experimental_async_interface* experimental_async() { return nullptr; }
  private:
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetMembersResponse>* AsyncGetMembersRaw(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetMembersResponse>* PrepareAsyncGetMembersRaw(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>* TsoRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>* AsyncTsoRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>* PrepareAsyncTsoRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::BootstrapResponse>* AsyncBootstrapRaw(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::BootstrapResponse>* PrepareAsyncBootstrapRaw(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::IsBootstrappedResponse>* AsyncIsBootstrappedRaw(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::IsBootstrappedResponse>* PrepareAsyncIsBootstrappedRaw(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::AllocIDResponse>* AsyncAllocIDRaw(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::AllocIDResponse>* PrepareAsyncAllocIDRaw(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetStoreResponse>* AsyncGetStoreRaw(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetStoreResponse>* PrepareAsyncGetStoreRaw(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::PutStoreResponse>* AsyncPutStoreRaw(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::PutStoreResponse>* PrepareAsyncPutStoreRaw(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetAllStoresResponse>* AsyncGetAllStoresRaw(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetAllStoresResponse>* PrepareAsyncGetAllStoresRaw(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::StoreHeartbeatResponse>* AsyncStoreHeartbeatRaw(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::StoreHeartbeatResponse>* PrepareAsyncStoreHeartbeatRaw(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientReaderWriterInterface< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>* RegionHeartbeatRaw(::grpc::ClientContext* context) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>* AsyncRegionHeartbeatRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderWriterInterface< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>* PrepareAsyncRegionHeartbeatRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>* AsyncGetRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>* PrepareAsyncGetRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>* AsyncGetPrevRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>* PrepareAsyncGetPrevRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>* AsyncGetRegionByIDRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetRegionResponse>* PrepareAsyncGetRegionByIDRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::ScanRegionsResponse>* AsyncScanRegionsRaw(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::ScanRegionsResponse>* PrepareAsyncScanRegionsRaw(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::AskSplitResponse>* AsyncAskSplitRaw(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::AskSplitResponse>* PrepareAsyncAskSplitRaw(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetClusterConfigResponse>* AsyncGetClusterConfigRaw(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetClusterConfigResponse>* PrepareAsyncGetClusterConfigRaw(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::PutClusterConfigResponse>* AsyncPutClusterConfigRaw(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::PutClusterConfigResponse>* PrepareAsyncPutClusterConfigRaw(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::ScatterRegionResponse>* AsyncScatterRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::ScatterRegionResponse>* PrepareAsyncScatterRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetGCSafePointResponse>* AsyncGetGCSafePointRaw(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetGCSafePointResponse>* PrepareAsyncGetGCSafePointRaw(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::UpdateGCSafePointResponse>* AsyncUpdateGCSafePointRaw(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::UpdateGCSafePointResponse>* PrepareAsyncUpdateGCSafePointRaw(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetOperatorResponse>* AsyncGetOperatorRaw(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::schedulerpb::GetOperatorResponse>* PrepareAsyncGetOperatorRaw(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel);
    ::grpc::Status GetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::schedulerpb::GetMembersResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetMembersResponse>> AsyncGetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetMembersResponse>>(AsyncGetMembersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetMembersResponse>> PrepareAsyncGetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetMembersResponse>>(PrepareAsyncGetMembersRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>> Tso(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>>(TsoRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>> AsyncTso(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>>(AsyncTsoRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>> PrepareAsyncTso(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>>(PrepareAsyncTsoRaw(context, cq));
    }
    ::grpc::Status Bootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::schedulerpb::BootstrapResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::BootstrapResponse>> AsyncBootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::BootstrapResponse>>(AsyncBootstrapRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::BootstrapResponse>> PrepareAsyncBootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::BootstrapResponse>>(PrepareAsyncBootstrapRaw(context, request, cq));
    }
    ::grpc::Status IsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::schedulerpb::IsBootstrappedResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::IsBootstrappedResponse>> AsyncIsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::IsBootstrappedResponse>>(AsyncIsBootstrappedRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::IsBootstrappedResponse>> PrepareAsyncIsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::IsBootstrappedResponse>>(PrepareAsyncIsBootstrappedRaw(context, request, cq));
    }
    ::grpc::Status AllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::schedulerpb::AllocIDResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::AllocIDResponse>> AsyncAllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::AllocIDResponse>>(AsyncAllocIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::AllocIDResponse>> PrepareAsyncAllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::AllocIDResponse>>(PrepareAsyncAllocIDRaw(context, request, cq));
    }
    ::grpc::Status GetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::schedulerpb::GetStoreResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetStoreResponse>> AsyncGetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetStoreResponse>>(AsyncGetStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetStoreResponse>> PrepareAsyncGetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetStoreResponse>>(PrepareAsyncGetStoreRaw(context, request, cq));
    }
    ::grpc::Status PutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::schedulerpb::PutStoreResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::PutStoreResponse>> AsyncPutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::PutStoreResponse>>(AsyncPutStoreRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::PutStoreResponse>> PrepareAsyncPutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::PutStoreResponse>>(PrepareAsyncPutStoreRaw(context, request, cq));
    }
    ::grpc::Status GetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::schedulerpb::GetAllStoresResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetAllStoresResponse>> AsyncGetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetAllStoresResponse>>(AsyncGetAllStoresRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetAllStoresResponse>> PrepareAsyncGetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetAllStoresResponse>>(PrepareAsyncGetAllStoresRaw(context, request, cq));
    }
    ::grpc::Status StoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::schedulerpb::StoreHeartbeatResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::StoreHeartbeatResponse>> AsyncStoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::StoreHeartbeatResponse>>(AsyncStoreHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::StoreHeartbeatResponse>> PrepareAsyncStoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::StoreHeartbeatResponse>>(PrepareAsyncStoreHeartbeatRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientReaderWriter< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>> RegionHeartbeat(::grpc::ClientContext* context) {
      return std::unique_ptr< ::grpc::ClientReaderWriter< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>>(RegionHeartbeatRaw(context));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>> AsyncRegionHeartbeat(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>>(AsyncRegionHeartbeatRaw(context, cq, tag));
    }
    std::unique_ptr<  ::grpc::ClientAsyncReaderWriter< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>> PrepareAsyncRegionHeartbeat(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderWriter< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>>(PrepareAsyncRegionHeartbeatRaw(context, cq));
    }
    ::grpc::Status GetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::schedulerpb::GetRegionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>> AsyncGetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>>(AsyncGetRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>> PrepareAsyncGetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>>(PrepareAsyncGetRegionRaw(context, request, cq));
    }
    ::grpc::Status GetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::schedulerpb::GetRegionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>> AsyncGetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>>(AsyncGetPrevRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>> PrepareAsyncGetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>>(PrepareAsyncGetPrevRegionRaw(context, request, cq));
    }
    ::grpc::Status GetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::schedulerpb::GetRegionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>> AsyncGetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>>(AsyncGetRegionByIDRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>> PrepareAsyncGetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>>(PrepareAsyncGetRegionByIDRaw(context, request, cq));
    }
    ::grpc::Status ScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::schedulerpb::ScanRegionsResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::ScanRegionsResponse>> AsyncScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::ScanRegionsResponse>>(AsyncScanRegionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::ScanRegionsResponse>> PrepareAsyncScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::ScanRegionsResponse>>(PrepareAsyncScanRegionsRaw(context, request, cq));
    }
    ::grpc::Status AskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::schedulerpb::AskSplitResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::AskSplitResponse>> AsyncAskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::AskSplitResponse>>(AsyncAskSplitRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::AskSplitResponse>> PrepareAsyncAskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::AskSplitResponse>>(PrepareAsyncAskSplitRaw(context, request, cq));
    }
    ::grpc::Status GetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::schedulerpb::GetClusterConfigResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetClusterConfigResponse>> AsyncGetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetClusterConfigResponse>>(AsyncGetClusterConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetClusterConfigResponse>> PrepareAsyncGetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetClusterConfigResponse>>(PrepareAsyncGetClusterConfigRaw(context, request, cq));
    }
    ::grpc::Status PutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::schedulerpb::PutClusterConfigResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::PutClusterConfigResponse>> AsyncPutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::PutClusterConfigResponse>>(AsyncPutClusterConfigRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::PutClusterConfigResponse>> PrepareAsyncPutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::PutClusterConfigResponse>>(PrepareAsyncPutClusterConfigRaw(context, request, cq));
    }
    ::grpc::Status ScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::schedulerpb::ScatterRegionResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::ScatterRegionResponse>> AsyncScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::ScatterRegionResponse>>(AsyncScatterRegionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::ScatterRegionResponse>> PrepareAsyncScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::ScatterRegionResponse>>(PrepareAsyncScatterRegionRaw(context, request, cq));
    }
    ::grpc::Status GetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::schedulerpb::GetGCSafePointResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetGCSafePointResponse>> AsyncGetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetGCSafePointResponse>>(AsyncGetGCSafePointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetGCSafePointResponse>> PrepareAsyncGetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetGCSafePointResponse>>(PrepareAsyncGetGCSafePointRaw(context, request, cq));
    }
    ::grpc::Status UpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::schedulerpb::UpdateGCSafePointResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::UpdateGCSafePointResponse>> AsyncUpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::UpdateGCSafePointResponse>>(AsyncUpdateGCSafePointRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::UpdateGCSafePointResponse>> PrepareAsyncUpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::UpdateGCSafePointResponse>>(PrepareAsyncUpdateGCSafePointRaw(context, request, cq));
    }
    ::grpc::Status GetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::schedulerpb::GetOperatorResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetOperatorResponse>> AsyncGetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetOperatorResponse>>(AsyncGetOperatorRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetOperatorResponse>> PrepareAsyncGetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetOperatorResponse>>(PrepareAsyncGetOperatorRaw(context, request, cq));
    }
    class experimental_async final :
      public StubInterface::experimental_async_interface {
     public:
      void GetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest* request, ::schedulerpb::GetMembersResponse* response, std::function<void(::grpc::Status)>) override;
      void GetMembers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetMembersResponse* response, std::function<void(::grpc::Status)>) override;
      void GetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest* request, ::schedulerpb::GetMembersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetMembers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetMembersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Tso(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::schedulerpb::TsoRequest,::schedulerpb::TsoResponse>* reactor) override;
      void Bootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest* request, ::schedulerpb::BootstrapResponse* response, std::function<void(::grpc::Status)>) override;
      void Bootstrap(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::BootstrapResponse* response, std::function<void(::grpc::Status)>) override;
      void Bootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest* request, ::schedulerpb::BootstrapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void Bootstrap(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::BootstrapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void IsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest* request, ::schedulerpb::IsBootstrappedResponse* response, std::function<void(::grpc::Status)>) override;
      void IsBootstrapped(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::IsBootstrappedResponse* response, std::function<void(::grpc::Status)>) override;
      void IsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest* request, ::schedulerpb::IsBootstrappedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void IsBootstrapped(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::IsBootstrappedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest* request, ::schedulerpb::AllocIDResponse* response, std::function<void(::grpc::Status)>) override;
      void AllocID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::AllocIDResponse* response, std::function<void(::grpc::Status)>) override;
      void AllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest* request, ::schedulerpb::AllocIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AllocID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::AllocIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest* request, ::schedulerpb::GetStoreResponse* response, std::function<void(::grpc::Status)>) override;
      void GetStore(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetStoreResponse* response, std::function<void(::grpc::Status)>) override;
      void GetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest* request, ::schedulerpb::GetStoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetStore(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetStoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest* request, ::schedulerpb::PutStoreResponse* response, std::function<void(::grpc::Status)>) override;
      void PutStore(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::PutStoreResponse* response, std::function<void(::grpc::Status)>) override;
      void PutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest* request, ::schedulerpb::PutStoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PutStore(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::PutStoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest* request, ::schedulerpb::GetAllStoresResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAllStores(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetAllStoresResponse* response, std::function<void(::grpc::Status)>) override;
      void GetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest* request, ::schedulerpb::GetAllStoresResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetAllStores(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetAllStoresResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest* request, ::schedulerpb::StoreHeartbeatResponse* response, std::function<void(::grpc::Status)>) override;
      void StoreHeartbeat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::StoreHeartbeatResponse* response, std::function<void(::grpc::Status)>) override;
      void StoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest* request, ::schedulerpb::StoreHeartbeatResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void StoreHeartbeat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::StoreHeartbeatResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void RegionHeartbeat(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::schedulerpb::RegionHeartbeatRequest,::schedulerpb::RegionHeartbeatResponse>* reactor) override;
      void GetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetPrevRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetPrevRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRegionByID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)>) override;
      void GetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetRegionByID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest* request, ::schedulerpb::ScanRegionsResponse* response, std::function<void(::grpc::Status)>) override;
      void ScanRegions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::ScanRegionsResponse* response, std::function<void(::grpc::Status)>) override;
      void ScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest* request, ::schedulerpb::ScanRegionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ScanRegions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::ScanRegionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest* request, ::schedulerpb::AskSplitResponse* response, std::function<void(::grpc::Status)>) override;
      void AskSplit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::AskSplitResponse* response, std::function<void(::grpc::Status)>) override;
      void AskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest* request, ::schedulerpb::AskSplitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void AskSplit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::AskSplitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest* request, ::schedulerpb::GetClusterConfigResponse* response, std::function<void(::grpc::Status)>) override;
      void GetClusterConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetClusterConfigResponse* response, std::function<void(::grpc::Status)>) override;
      void GetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest* request, ::schedulerpb::GetClusterConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetClusterConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetClusterConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest* request, ::schedulerpb::PutClusterConfigResponse* response, std::function<void(::grpc::Status)>) override;
      void PutClusterConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::PutClusterConfigResponse* response, std::function<void(::grpc::Status)>) override;
      void PutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest* request, ::schedulerpb::PutClusterConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void PutClusterConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::PutClusterConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest* request, ::schedulerpb::ScatterRegionResponse* response, std::function<void(::grpc::Status)>) override;
      void ScatterRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::ScatterRegionResponse* response, std::function<void(::grpc::Status)>) override;
      void ScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest* request, ::schedulerpb::ScatterRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void ScatterRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::ScatterRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest* request, ::schedulerpb::GetGCSafePointResponse* response, std::function<void(::grpc::Status)>) override;
      void GetGCSafePoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetGCSafePointResponse* response, std::function<void(::grpc::Status)>) override;
      void GetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest* request, ::schedulerpb::GetGCSafePointResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetGCSafePoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetGCSafePointResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest* request, ::schedulerpb::UpdateGCSafePointResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateGCSafePoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::UpdateGCSafePointResponse* response, std::function<void(::grpc::Status)>) override;
      void UpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest* request, ::schedulerpb::UpdateGCSafePointResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void UpdateGCSafePoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::UpdateGCSafePointResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest* request, ::schedulerpb::GetOperatorResponse* response, std::function<void(::grpc::Status)>) override;
      void GetOperator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetOperatorResponse* response, std::function<void(::grpc::Status)>) override;
      void GetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest* request, ::schedulerpb::GetOperatorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
      void GetOperator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetOperatorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit experimental_async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class experimental_async_interface* experimental_async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class experimental_async async_stub_{this};
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetMembersResponse>* AsyncGetMembersRaw(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetMembersResponse>* PrepareAsyncGetMembersRaw(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>* TsoRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>* AsyncTsoRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>* PrepareAsyncTsoRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::BootstrapResponse>* AsyncBootstrapRaw(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::BootstrapResponse>* PrepareAsyncBootstrapRaw(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::IsBootstrappedResponse>* AsyncIsBootstrappedRaw(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::IsBootstrappedResponse>* PrepareAsyncIsBootstrappedRaw(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::AllocIDResponse>* AsyncAllocIDRaw(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::AllocIDResponse>* PrepareAsyncAllocIDRaw(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetStoreResponse>* AsyncGetStoreRaw(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetStoreResponse>* PrepareAsyncGetStoreRaw(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::PutStoreResponse>* AsyncPutStoreRaw(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::PutStoreResponse>* PrepareAsyncPutStoreRaw(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetAllStoresResponse>* AsyncGetAllStoresRaw(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetAllStoresResponse>* PrepareAsyncGetAllStoresRaw(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::StoreHeartbeatResponse>* AsyncStoreHeartbeatRaw(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::StoreHeartbeatResponse>* PrepareAsyncStoreHeartbeatRaw(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientReaderWriter< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>* RegionHeartbeatRaw(::grpc::ClientContext* context) override;
    ::grpc::ClientAsyncReaderWriter< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>* AsyncRegionHeartbeatRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReaderWriter< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>* PrepareAsyncRegionHeartbeatRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>* AsyncGetRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>* PrepareAsyncGetRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>* AsyncGetPrevRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>* PrepareAsyncGetPrevRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>* AsyncGetRegionByIDRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>* PrepareAsyncGetRegionByIDRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::ScanRegionsResponse>* AsyncScanRegionsRaw(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::ScanRegionsResponse>* PrepareAsyncScanRegionsRaw(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::AskSplitResponse>* AsyncAskSplitRaw(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::AskSplitResponse>* PrepareAsyncAskSplitRaw(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetClusterConfigResponse>* AsyncGetClusterConfigRaw(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetClusterConfigResponse>* PrepareAsyncGetClusterConfigRaw(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::PutClusterConfigResponse>* AsyncPutClusterConfigRaw(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::PutClusterConfigResponse>* PrepareAsyncPutClusterConfigRaw(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::ScatterRegionResponse>* AsyncScatterRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::ScatterRegionResponse>* PrepareAsyncScatterRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetGCSafePointResponse>* AsyncGetGCSafePointRaw(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetGCSafePointResponse>* PrepareAsyncGetGCSafePointRaw(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::UpdateGCSafePointResponse>* AsyncUpdateGCSafePointRaw(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::UpdateGCSafePointResponse>* PrepareAsyncUpdateGCSafePointRaw(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetOperatorResponse>* AsyncGetOperatorRaw(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::schedulerpb::GetOperatorResponse>* PrepareAsyncGetOperatorRaw(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetMembers_;
    const ::grpc::internal::RpcMethod rpcmethod_Tso_;
    const ::grpc::internal::RpcMethod rpcmethod_Bootstrap_;
    const ::grpc::internal::RpcMethod rpcmethod_IsBootstrapped_;
    const ::grpc::internal::RpcMethod rpcmethod_AllocID_;
    const ::grpc::internal::RpcMethod rpcmethod_GetStore_;
    const ::grpc::internal::RpcMethod rpcmethod_PutStore_;
    const ::grpc::internal::RpcMethod rpcmethod_GetAllStores_;
    const ::grpc::internal::RpcMethod rpcmethod_StoreHeartbeat_;
    const ::grpc::internal::RpcMethod rpcmethod_RegionHeartbeat_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRegion_;
    const ::grpc::internal::RpcMethod rpcmethod_GetPrevRegion_;
    const ::grpc::internal::RpcMethod rpcmethod_GetRegionByID_;
    const ::grpc::internal::RpcMethod rpcmethod_ScanRegions_;
    const ::grpc::internal::RpcMethod rpcmethod_AskSplit_;
    const ::grpc::internal::RpcMethod rpcmethod_GetClusterConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_PutClusterConfig_;
    const ::grpc::internal::RpcMethod rpcmethod_ScatterRegion_;
    const ::grpc::internal::RpcMethod rpcmethod_GetGCSafePoint_;
    const ::grpc::internal::RpcMethod rpcmethod_UpdateGCSafePoint_;
    const ::grpc::internal::RpcMethod rpcmethod_GetOperator_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    // GetMembers get the member list of this cluster. It does not require
    // the cluster_id in request matchs the id of this cluster.
    virtual ::grpc::Status GetMembers(::grpc::ServerContext* context, const ::schedulerpb::GetMembersRequest* request, ::schedulerpb::GetMembersResponse* response);
    virtual ::grpc::Status Tso(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::schedulerpb::TsoResponse, ::schedulerpb::TsoRequest>* stream);
    virtual ::grpc::Status Bootstrap(::grpc::ServerContext* context, const ::schedulerpb::BootstrapRequest* request, ::schedulerpb::BootstrapResponse* response);
    virtual ::grpc::Status IsBootstrapped(::grpc::ServerContext* context, const ::schedulerpb::IsBootstrappedRequest* request, ::schedulerpb::IsBootstrappedResponse* response);
    virtual ::grpc::Status AllocID(::grpc::ServerContext* context, const ::schedulerpb::AllocIDRequest* request, ::schedulerpb::AllocIDResponse* response);
    virtual ::grpc::Status GetStore(::grpc::ServerContext* context, const ::schedulerpb::GetStoreRequest* request, ::schedulerpb::GetStoreResponse* response);
    virtual ::grpc::Status PutStore(::grpc::ServerContext* context, const ::schedulerpb::PutStoreRequest* request, ::schedulerpb::PutStoreResponse* response);
    virtual ::grpc::Status GetAllStores(::grpc::ServerContext* context, const ::schedulerpb::GetAllStoresRequest* request, ::schedulerpb::GetAllStoresResponse* response);
    virtual ::grpc::Status StoreHeartbeat(::grpc::ServerContext* context, const ::schedulerpb::StoreHeartbeatRequest* request, ::schedulerpb::StoreHeartbeatResponse* response);
    virtual ::grpc::Status RegionHeartbeat(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::schedulerpb::RegionHeartbeatResponse, ::schedulerpb::RegionHeartbeatRequest>* stream);
    virtual ::grpc::Status GetRegion(::grpc::ServerContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response);
    virtual ::grpc::Status GetPrevRegion(::grpc::ServerContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response);
    virtual ::grpc::Status GetRegionByID(::grpc::ServerContext* context, const ::schedulerpb::GetRegionByIDRequest* request, ::schedulerpb::GetRegionResponse* response);
    virtual ::grpc::Status ScanRegions(::grpc::ServerContext* context, const ::schedulerpb::ScanRegionsRequest* request, ::schedulerpb::ScanRegionsResponse* response);
    virtual ::grpc::Status AskSplit(::grpc::ServerContext* context, const ::schedulerpb::AskSplitRequest* request, ::schedulerpb::AskSplitResponse* response);
    virtual ::grpc::Status GetClusterConfig(::grpc::ServerContext* context, const ::schedulerpb::GetClusterConfigRequest* request, ::schedulerpb::GetClusterConfigResponse* response);
    virtual ::grpc::Status PutClusterConfig(::grpc::ServerContext* context, const ::schedulerpb::PutClusterConfigRequest* request, ::schedulerpb::PutClusterConfigResponse* response);
    virtual ::grpc::Status ScatterRegion(::grpc::ServerContext* context, const ::schedulerpb::ScatterRegionRequest* request, ::schedulerpb::ScatterRegionResponse* response);
    virtual ::grpc::Status GetGCSafePoint(::grpc::ServerContext* context, const ::schedulerpb::GetGCSafePointRequest* request, ::schedulerpb::GetGCSafePointResponse* response);
    virtual ::grpc::Status UpdateGCSafePoint(::grpc::ServerContext* context, const ::schedulerpb::UpdateGCSafePointRequest* request, ::schedulerpb::UpdateGCSafePointResponse* response);
    virtual ::grpc::Status GetOperator(::grpc::ServerContext* context, const ::schedulerpb::GetOperatorRequest* request, ::schedulerpb::GetOperatorResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetMembers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetMembers() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetMembers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMembers(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetMembersRequest* /*request*/, ::schedulerpb::GetMembersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMembers(::grpc::ServerContext* context, ::schedulerpb::GetMembersRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::GetMembersResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Tso : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Tso() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_Tso() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tso(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::schedulerpb::TsoResponse, ::schedulerpb::TsoRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTso(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::schedulerpb::TsoResponse, ::schedulerpb::TsoRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(1, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Bootstrap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Bootstrap() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_Bootstrap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bootstrap(::grpc::ServerContext* /*context*/, const ::schedulerpb::BootstrapRequest* /*request*/, ::schedulerpb::BootstrapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBootstrap(::grpc::ServerContext* context, ::schedulerpb::BootstrapRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::BootstrapResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_IsBootstrapped : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_IsBootstrapped() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_IsBootstrapped() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBootstrapped(::grpc::ServerContext* /*context*/, const ::schedulerpb::IsBootstrappedRequest* /*request*/, ::schedulerpb::IsBootstrappedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsBootstrapped(::grpc::ServerContext* context, ::schedulerpb::IsBootstrappedRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::IsBootstrappedResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AllocID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AllocID() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_AllocID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllocID(::grpc::ServerContext* /*context*/, const ::schedulerpb::AllocIDRequest* /*request*/, ::schedulerpb::AllocIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAllocID(::grpc::ServerContext* context, ::schedulerpb::AllocIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::AllocIDResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetStore() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_GetStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetStoreRequest* /*request*/, ::schedulerpb::GetStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStore(::grpc::ServerContext* context, ::schedulerpb::GetStoreRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::GetStoreResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PutStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PutStore() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_PutStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutStoreRequest* /*request*/, ::schedulerpb::PutStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutStore(::grpc::ServerContext* context, ::schedulerpb::PutStoreRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::PutStoreResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetAllStores : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetAllStores() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_GetAllStores() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllStores(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetAllStoresRequest* /*request*/, ::schedulerpb::GetAllStoresResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllStores(::grpc::ServerContext* context, ::schedulerpb::GetAllStoresRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::GetAllStoresResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_StoreHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_StoreHeartbeat() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_StoreHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreHeartbeat(::grpc::ServerContext* /*context*/, const ::schedulerpb::StoreHeartbeatRequest* /*request*/, ::schedulerpb::StoreHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreHeartbeat(::grpc::ServerContext* context, ::schedulerpb::StoreHeartbeatRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::StoreHeartbeatResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_RegionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_RegionHeartbeat() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_RegionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegionHeartbeat(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::schedulerpb::RegionHeartbeatResponse, ::schedulerpb::RegionHeartbeatRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegionHeartbeat(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::schedulerpb::RegionHeartbeatResponse, ::schedulerpb::RegionHeartbeatRequest>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(9, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRegion() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_GetRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRegion(::grpc::ServerContext* context, ::schedulerpb::GetRegionRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::GetRegionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetPrevRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetPrevRegion() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_GetPrevRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPrevRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPrevRegion(::grpc::ServerContext* context, ::schedulerpb::GetRegionRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::GetRegionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetRegionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetRegionByID() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_GetRegionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegionByID(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionByIDRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRegionByID(::grpc::ServerContext* context, ::schedulerpb::GetRegionByIDRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::GetRegionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ScanRegions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ScanRegions() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_ScanRegions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScanRegions(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScanRegionsRequest* /*request*/, ::schedulerpb::ScanRegionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScanRegions(::grpc::ServerContext* context, ::schedulerpb::ScanRegionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::ScanRegionsResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_AskSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_AskSplit() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_AskSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AskSplit(::grpc::ServerContext* /*context*/, const ::schedulerpb::AskSplitRequest* /*request*/, ::schedulerpb::AskSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAskSplit(::grpc::ServerContext* context, ::schedulerpb::AskSplitRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::AskSplitResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetClusterConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetClusterConfig() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_GetClusterConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetClusterConfigRequest* /*request*/, ::schedulerpb::GetClusterConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetClusterConfig(::grpc::ServerContext* context, ::schedulerpb::GetClusterConfigRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::GetClusterConfigResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_PutClusterConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_PutClusterConfig() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_PutClusterConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutClusterConfigRequest* /*request*/, ::schedulerpb::PutClusterConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutClusterConfig(::grpc::ServerContext* context, ::schedulerpb::PutClusterConfigRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::PutClusterConfigResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ScatterRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ScatterRegion() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_ScatterRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScatterRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScatterRegionRequest* /*request*/, ::schedulerpb::ScatterRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScatterRegion(::grpc::ServerContext* context, ::schedulerpb::ScatterRegionRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::ScatterRegionResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetGCSafePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetGCSafePoint() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_GetGCSafePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetGCSafePointRequest* /*request*/, ::schedulerpb::GetGCSafePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGCSafePoint(::grpc::ServerContext* context, ::schedulerpb::GetGCSafePointRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::GetGCSafePointResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UpdateGCSafePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UpdateGCSafePoint() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_UpdateGCSafePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::UpdateGCSafePointRequest* /*request*/, ::schedulerpb::UpdateGCSafePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateGCSafePoint(::grpc::ServerContext* context, ::schedulerpb::UpdateGCSafePointRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::UpdateGCSafePointResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetOperator : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetOperator() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_GetOperator() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperator(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetOperatorRequest* /*request*/, ::schedulerpb::GetOperatorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOperator(::grpc::ServerContext* context, ::schedulerpb::GetOperatorRequest* request, ::grpc::ServerAsyncResponseWriter< ::schedulerpb::GetOperatorResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetMembers<WithAsyncMethod_Tso<WithAsyncMethod_Bootstrap<WithAsyncMethod_IsBootstrapped<WithAsyncMethod_AllocID<WithAsyncMethod_GetStore<WithAsyncMethod_PutStore<WithAsyncMethod_GetAllStores<WithAsyncMethod_StoreHeartbeat<WithAsyncMethod_RegionHeartbeat<WithAsyncMethod_GetRegion<WithAsyncMethod_GetPrevRegion<WithAsyncMethod_GetRegionByID<WithAsyncMethod_ScanRegions<WithAsyncMethod_AskSplit<WithAsyncMethod_GetClusterConfig<WithAsyncMethod_PutClusterConfig<WithAsyncMethod_ScatterRegion<WithAsyncMethod_GetGCSafePoint<WithAsyncMethod_UpdateGCSafePoint<WithAsyncMethod_GetOperator<Service > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetMembers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetMembers() {
      ::grpc::Service::experimental().MarkMethodCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetMembersRequest, ::schedulerpb::GetMembersResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::GetMembersRequest* request,
                 ::schedulerpb::GetMembersResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetMembers(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetMembers(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::GetMembersRequest, ::schedulerpb::GetMembersResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetMembersRequest, ::schedulerpb::GetMembersResponse>*>(
          ::grpc::Service::experimental().GetHandler(0))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetMembers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMembers(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetMembersRequest* /*request*/, ::schedulerpb::GetMembersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMembers(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetMembersRequest* /*request*/, ::schedulerpb::GetMembersResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Tso : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Tso() {
      ::grpc::Service::experimental().MarkMethodCallback(1,
        new ::grpc_impl::internal::CallbackBidiHandler< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>(
          [this] { return this->Tso(); }));
    }
    ~ExperimentalWithCallbackMethod_Tso() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tso(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::schedulerpb::TsoResponse, ::schedulerpb::TsoRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerBidiReactor< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>* Tso() {
      return new ::grpc_impl::internal::UnimplementedBidiReactor<
        ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_Bootstrap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_Bootstrap() {
      ::grpc::Service::experimental().MarkMethodCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::BootstrapRequest, ::schedulerpb::BootstrapResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::BootstrapRequest* request,
                 ::schedulerpb::BootstrapResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->Bootstrap(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_Bootstrap(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::BootstrapRequest, ::schedulerpb::BootstrapResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::BootstrapRequest, ::schedulerpb::BootstrapResponse>*>(
          ::grpc::Service::experimental().GetHandler(2))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_Bootstrap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bootstrap(::grpc::ServerContext* /*context*/, const ::schedulerpb::BootstrapRequest* /*request*/, ::schedulerpb::BootstrapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Bootstrap(::grpc::ServerContext* /*context*/, const ::schedulerpb::BootstrapRequest* /*request*/, ::schedulerpb::BootstrapResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_IsBootstrapped : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_IsBootstrapped() {
      ::grpc::Service::experimental().MarkMethodCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::IsBootstrappedRequest, ::schedulerpb::IsBootstrappedResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::IsBootstrappedRequest* request,
                 ::schedulerpb::IsBootstrappedResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->IsBootstrapped(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_IsBootstrapped(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::IsBootstrappedRequest, ::schedulerpb::IsBootstrappedResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::IsBootstrappedRequest, ::schedulerpb::IsBootstrappedResponse>*>(
          ::grpc::Service::experimental().GetHandler(3))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_IsBootstrapped() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBootstrapped(::grpc::ServerContext* /*context*/, const ::schedulerpb::IsBootstrappedRequest* /*request*/, ::schedulerpb::IsBootstrappedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void IsBootstrapped(::grpc::ServerContext* /*context*/, const ::schedulerpb::IsBootstrappedRequest* /*request*/, ::schedulerpb::IsBootstrappedResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AllocID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AllocID() {
      ::grpc::Service::experimental().MarkMethodCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::AllocIDRequest, ::schedulerpb::AllocIDResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::AllocIDRequest* request,
                 ::schedulerpb::AllocIDResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AllocID(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AllocID(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::AllocIDRequest, ::schedulerpb::AllocIDResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::AllocIDRequest, ::schedulerpb::AllocIDResponse>*>(
          ::grpc::Service::experimental().GetHandler(4))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AllocID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllocID(::grpc::ServerContext* /*context*/, const ::schedulerpb::AllocIDRequest* /*request*/, ::schedulerpb::AllocIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AllocID(::grpc::ServerContext* /*context*/, const ::schedulerpb::AllocIDRequest* /*request*/, ::schedulerpb::AllocIDResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetStore() {
      ::grpc::Service::experimental().MarkMethodCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetStoreRequest, ::schedulerpb::GetStoreResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::GetStoreRequest* request,
                 ::schedulerpb::GetStoreResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetStore(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetStore(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::GetStoreRequest, ::schedulerpb::GetStoreResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetStoreRequest, ::schedulerpb::GetStoreResponse>*>(
          ::grpc::Service::experimental().GetHandler(5))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetStoreRequest* /*request*/, ::schedulerpb::GetStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetStoreRequest* /*request*/, ::schedulerpb::GetStoreResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PutStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PutStore() {
      ::grpc::Service::experimental().MarkMethodCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::PutStoreRequest, ::schedulerpb::PutStoreResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::PutStoreRequest* request,
                 ::schedulerpb::PutStoreResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->PutStore(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_PutStore(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::PutStoreRequest, ::schedulerpb::PutStoreResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::PutStoreRequest, ::schedulerpb::PutStoreResponse>*>(
          ::grpc::Service::experimental().GetHandler(6))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PutStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutStoreRequest* /*request*/, ::schedulerpb::PutStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void PutStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutStoreRequest* /*request*/, ::schedulerpb::PutStoreResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetAllStores : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetAllStores() {
      ::grpc::Service::experimental().MarkMethodCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetAllStoresRequest, ::schedulerpb::GetAllStoresResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::GetAllStoresRequest* request,
                 ::schedulerpb::GetAllStoresResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetAllStores(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetAllStores(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::GetAllStoresRequest, ::schedulerpb::GetAllStoresResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetAllStoresRequest, ::schedulerpb::GetAllStoresResponse>*>(
          ::grpc::Service::experimental().GetHandler(7))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetAllStores() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllStores(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetAllStoresRequest* /*request*/, ::schedulerpb::GetAllStoresResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAllStores(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetAllStoresRequest* /*request*/, ::schedulerpb::GetAllStoresResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_StoreHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_StoreHeartbeat() {
      ::grpc::Service::experimental().MarkMethodCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::StoreHeartbeatRequest, ::schedulerpb::StoreHeartbeatResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::StoreHeartbeatRequest* request,
                 ::schedulerpb::StoreHeartbeatResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->StoreHeartbeat(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_StoreHeartbeat(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::StoreHeartbeatRequest, ::schedulerpb::StoreHeartbeatResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::StoreHeartbeatRequest, ::schedulerpb::StoreHeartbeatResponse>*>(
          ::grpc::Service::experimental().GetHandler(8))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_StoreHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreHeartbeat(::grpc::ServerContext* /*context*/, const ::schedulerpb::StoreHeartbeatRequest* /*request*/, ::schedulerpb::StoreHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreHeartbeat(::grpc::ServerContext* /*context*/, const ::schedulerpb::StoreHeartbeatRequest* /*request*/, ::schedulerpb::StoreHeartbeatResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_RegionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_RegionHeartbeat() {
      ::grpc::Service::experimental().MarkMethodCallback(9,
        new ::grpc_impl::internal::CallbackBidiHandler< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>(
          [this] { return this->RegionHeartbeat(); }));
    }
    ~ExperimentalWithCallbackMethod_RegionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegionHeartbeat(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::schedulerpb::RegionHeartbeatResponse, ::schedulerpb::RegionHeartbeatRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerBidiReactor< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>* RegionHeartbeat() {
      return new ::grpc_impl::internal::UnimplementedBidiReactor<
        ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>;}
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRegion() {
      ::grpc::Service::experimental().MarkMethodCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetRegionRequest, ::schedulerpb::GetRegionResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::GetRegionRequest* request,
                 ::schedulerpb::GetRegionResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetRegion(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetRegion(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::GetRegionRequest, ::schedulerpb::GetRegionResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetRegionRequest, ::schedulerpb::GetRegionResponse>*>(
          ::grpc::Service::experimental().GetHandler(10))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetPrevRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetPrevRegion() {
      ::grpc::Service::experimental().MarkMethodCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetRegionRequest, ::schedulerpb::GetRegionResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::GetRegionRequest* request,
                 ::schedulerpb::GetRegionResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetPrevRegion(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetPrevRegion(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::GetRegionRequest, ::schedulerpb::GetRegionResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetRegionRequest, ::schedulerpb::GetRegionResponse>*>(
          ::grpc::Service::experimental().GetHandler(11))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetPrevRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPrevRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPrevRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetRegionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetRegionByID() {
      ::grpc::Service::experimental().MarkMethodCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetRegionByIDRequest, ::schedulerpb::GetRegionResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::GetRegionByIDRequest* request,
                 ::schedulerpb::GetRegionResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetRegionByID(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetRegionByID(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::GetRegionByIDRequest, ::schedulerpb::GetRegionResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetRegionByIDRequest, ::schedulerpb::GetRegionResponse>*>(
          ::grpc::Service::experimental().GetHandler(12))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetRegionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegionByID(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionByIDRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRegionByID(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionByIDRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ScanRegions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ScanRegions() {
      ::grpc::Service::experimental().MarkMethodCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::ScanRegionsRequest, ::schedulerpb::ScanRegionsResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::ScanRegionsRequest* request,
                 ::schedulerpb::ScanRegionsResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ScanRegions(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ScanRegions(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::ScanRegionsRequest, ::schedulerpb::ScanRegionsResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::ScanRegionsRequest, ::schedulerpb::ScanRegionsResponse>*>(
          ::grpc::Service::experimental().GetHandler(13))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ScanRegions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScanRegions(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScanRegionsRequest* /*request*/, ::schedulerpb::ScanRegionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ScanRegions(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScanRegionsRequest* /*request*/, ::schedulerpb::ScanRegionsResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_AskSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_AskSplit() {
      ::grpc::Service::experimental().MarkMethodCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::AskSplitRequest, ::schedulerpb::AskSplitResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::AskSplitRequest* request,
                 ::schedulerpb::AskSplitResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->AskSplit(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_AskSplit(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::AskSplitRequest, ::schedulerpb::AskSplitResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::AskSplitRequest, ::schedulerpb::AskSplitResponse>*>(
          ::grpc::Service::experimental().GetHandler(14))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_AskSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AskSplit(::grpc::ServerContext* /*context*/, const ::schedulerpb::AskSplitRequest* /*request*/, ::schedulerpb::AskSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AskSplit(::grpc::ServerContext* /*context*/, const ::schedulerpb::AskSplitRequest* /*request*/, ::schedulerpb::AskSplitResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetClusterConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetClusterConfig() {
      ::grpc::Service::experimental().MarkMethodCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetClusterConfigRequest, ::schedulerpb::GetClusterConfigResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::GetClusterConfigRequest* request,
                 ::schedulerpb::GetClusterConfigResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetClusterConfig(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetClusterConfig(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::GetClusterConfigRequest, ::schedulerpb::GetClusterConfigResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetClusterConfigRequest, ::schedulerpb::GetClusterConfigResponse>*>(
          ::grpc::Service::experimental().GetHandler(15))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetClusterConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetClusterConfigRequest* /*request*/, ::schedulerpb::GetClusterConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetClusterConfigRequest* /*request*/, ::schedulerpb::GetClusterConfigResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_PutClusterConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_PutClusterConfig() {
      ::grpc::Service::experimental().MarkMethodCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::PutClusterConfigRequest, ::schedulerpb::PutClusterConfigResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::PutClusterConfigRequest* request,
                 ::schedulerpb::PutClusterConfigResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->PutClusterConfig(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_PutClusterConfig(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::PutClusterConfigRequest, ::schedulerpb::PutClusterConfigResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::PutClusterConfigRequest, ::schedulerpb::PutClusterConfigResponse>*>(
          ::grpc::Service::experimental().GetHandler(16))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_PutClusterConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutClusterConfigRequest* /*request*/, ::schedulerpb::PutClusterConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void PutClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutClusterConfigRequest* /*request*/, ::schedulerpb::PutClusterConfigResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_ScatterRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_ScatterRegion() {
      ::grpc::Service::experimental().MarkMethodCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::ScatterRegionRequest, ::schedulerpb::ScatterRegionResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::ScatterRegionRequest* request,
                 ::schedulerpb::ScatterRegionResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->ScatterRegion(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_ScatterRegion(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::ScatterRegionRequest, ::schedulerpb::ScatterRegionResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::ScatterRegionRequest, ::schedulerpb::ScatterRegionResponse>*>(
          ::grpc::Service::experimental().GetHandler(17))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_ScatterRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScatterRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScatterRegionRequest* /*request*/, ::schedulerpb::ScatterRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ScatterRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScatterRegionRequest* /*request*/, ::schedulerpb::ScatterRegionResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetGCSafePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetGCSafePoint() {
      ::grpc::Service::experimental().MarkMethodCallback(18,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetGCSafePointRequest, ::schedulerpb::GetGCSafePointResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::GetGCSafePointRequest* request,
                 ::schedulerpb::GetGCSafePointResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetGCSafePoint(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetGCSafePoint(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::GetGCSafePointRequest, ::schedulerpb::GetGCSafePointResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetGCSafePointRequest, ::schedulerpb::GetGCSafePointResponse>*>(
          ::grpc::Service::experimental().GetHandler(18))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetGCSafePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetGCSafePointRequest* /*request*/, ::schedulerpb::GetGCSafePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetGCSafePointRequest* /*request*/, ::schedulerpb::GetGCSafePointResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_UpdateGCSafePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_UpdateGCSafePoint() {
      ::grpc::Service::experimental().MarkMethodCallback(19,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::UpdateGCSafePointRequest, ::schedulerpb::UpdateGCSafePointResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::UpdateGCSafePointRequest* request,
                 ::schedulerpb::UpdateGCSafePointResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->UpdateGCSafePoint(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_UpdateGCSafePoint(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::UpdateGCSafePointRequest, ::schedulerpb::UpdateGCSafePointResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::UpdateGCSafePointRequest, ::schedulerpb::UpdateGCSafePointResponse>*>(
          ::grpc::Service::experimental().GetHandler(19))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_UpdateGCSafePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::UpdateGCSafePointRequest* /*request*/, ::schedulerpb::UpdateGCSafePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::UpdateGCSafePointRequest* /*request*/, ::schedulerpb::UpdateGCSafePointResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithCallbackMethod_GetOperator : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithCallbackMethod_GetOperator() {
      ::grpc::Service::experimental().MarkMethodCallback(20,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetOperatorRequest, ::schedulerpb::GetOperatorResponse>(
          [this](::grpc::ServerContext* context,
                 const ::schedulerpb::GetOperatorRequest* request,
                 ::schedulerpb::GetOperatorResponse* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   return this->GetOperator(context, request, response, controller);
                 }));
    }
    void SetMessageAllocatorFor_GetOperator(
        ::grpc::experimental::MessageAllocator< ::schedulerpb::GetOperatorRequest, ::schedulerpb::GetOperatorResponse>* allocator) {
      static_cast<::grpc_impl::internal::CallbackUnaryHandler< ::schedulerpb::GetOperatorRequest, ::schedulerpb::GetOperatorResponse>*>(
          ::grpc::Service::experimental().GetHandler(20))
              ->SetMessageAllocator(allocator);
    }
    ~ExperimentalWithCallbackMethod_GetOperator() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperator(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetOperatorRequest* /*request*/, ::schedulerpb::GetOperatorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetOperator(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetOperatorRequest* /*request*/, ::schedulerpb::GetOperatorResponse* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  typedef ExperimentalWithCallbackMethod_GetMembers<ExperimentalWithCallbackMethod_Tso<ExperimentalWithCallbackMethod_Bootstrap<ExperimentalWithCallbackMethod_IsBootstrapped<ExperimentalWithCallbackMethod_AllocID<ExperimentalWithCallbackMethod_GetStore<ExperimentalWithCallbackMethod_PutStore<ExperimentalWithCallbackMethod_GetAllStores<ExperimentalWithCallbackMethod_StoreHeartbeat<ExperimentalWithCallbackMethod_RegionHeartbeat<ExperimentalWithCallbackMethod_GetRegion<ExperimentalWithCallbackMethod_GetPrevRegion<ExperimentalWithCallbackMethod_GetRegionByID<ExperimentalWithCallbackMethod_ScanRegions<ExperimentalWithCallbackMethod_AskSplit<ExperimentalWithCallbackMethod_GetClusterConfig<ExperimentalWithCallbackMethod_PutClusterConfig<ExperimentalWithCallbackMethod_ScatterRegion<ExperimentalWithCallbackMethod_GetGCSafePoint<ExperimentalWithCallbackMethod_UpdateGCSafePoint<ExperimentalWithCallbackMethod_GetOperator<Service > > > > > > > > > > > > > > > > > > > > > ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetMembers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetMembers() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetMembers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMembers(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetMembersRequest* /*request*/, ::schedulerpb::GetMembersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Tso : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Tso() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_Tso() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tso(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::schedulerpb::TsoResponse, ::schedulerpb::TsoRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Bootstrap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Bootstrap() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_Bootstrap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bootstrap(::grpc::ServerContext* /*context*/, const ::schedulerpb::BootstrapRequest* /*request*/, ::schedulerpb::BootstrapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_IsBootstrapped : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_IsBootstrapped() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_IsBootstrapped() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBootstrapped(::grpc::ServerContext* /*context*/, const ::schedulerpb::IsBootstrappedRequest* /*request*/, ::schedulerpb::IsBootstrappedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AllocID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AllocID() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_AllocID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllocID(::grpc::ServerContext* /*context*/, const ::schedulerpb::AllocIDRequest* /*request*/, ::schedulerpb::AllocIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetStore() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_GetStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetStoreRequest* /*request*/, ::schedulerpb::GetStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PutStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PutStore() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_PutStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutStoreRequest* /*request*/, ::schedulerpb::PutStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetAllStores : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetAllStores() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_GetAllStores() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllStores(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetAllStoresRequest* /*request*/, ::schedulerpb::GetAllStoresResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_StoreHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_StoreHeartbeat() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_StoreHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreHeartbeat(::grpc::ServerContext* /*context*/, const ::schedulerpb::StoreHeartbeatRequest* /*request*/, ::schedulerpb::StoreHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_RegionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_RegionHeartbeat() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_RegionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegionHeartbeat(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::schedulerpb::RegionHeartbeatResponse, ::schedulerpb::RegionHeartbeatRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRegion() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_GetRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetPrevRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetPrevRegion() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_GetPrevRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPrevRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetRegionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetRegionByID() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_GetRegionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegionByID(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionByIDRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ScanRegions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ScanRegions() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_ScanRegions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScanRegions(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScanRegionsRequest* /*request*/, ::schedulerpb::ScanRegionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_AskSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_AskSplit() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_AskSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AskSplit(::grpc::ServerContext* /*context*/, const ::schedulerpb::AskSplitRequest* /*request*/, ::schedulerpb::AskSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetClusterConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetClusterConfig() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_GetClusterConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetClusterConfigRequest* /*request*/, ::schedulerpb::GetClusterConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_PutClusterConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_PutClusterConfig() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_PutClusterConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutClusterConfigRequest* /*request*/, ::schedulerpb::PutClusterConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ScatterRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ScatterRegion() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_ScatterRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScatterRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScatterRegionRequest* /*request*/, ::schedulerpb::ScatterRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetGCSafePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetGCSafePoint() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_GetGCSafePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetGCSafePointRequest* /*request*/, ::schedulerpb::GetGCSafePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UpdateGCSafePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UpdateGCSafePoint() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_UpdateGCSafePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::UpdateGCSafePointRequest* /*request*/, ::schedulerpb::UpdateGCSafePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetOperator : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetOperator() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_GetOperator() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperator(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetOperatorRequest* /*request*/, ::schedulerpb::GetOperatorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetMembers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetMembers() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetMembers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMembers(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetMembersRequest* /*request*/, ::schedulerpb::GetMembersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetMembers(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(0, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Tso : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Tso() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_Tso() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tso(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::schedulerpb::TsoResponse, ::schedulerpb::TsoRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTso(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(1, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Bootstrap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Bootstrap() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_Bootstrap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bootstrap(::grpc::ServerContext* /*context*/, const ::schedulerpb::BootstrapRequest* /*request*/, ::schedulerpb::BootstrapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestBootstrap(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_IsBootstrapped : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_IsBootstrapped() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_IsBootstrapped() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBootstrapped(::grpc::ServerContext* /*context*/, const ::schedulerpb::IsBootstrappedRequest* /*request*/, ::schedulerpb::IsBootstrappedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestIsBootstrapped(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AllocID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AllocID() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_AllocID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllocID(::grpc::ServerContext* /*context*/, const ::schedulerpb::AllocIDRequest* /*request*/, ::schedulerpb::AllocIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAllocID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetStore() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_GetStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetStoreRequest* /*request*/, ::schedulerpb::GetStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetStore(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PutStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PutStore() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_PutStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutStoreRequest* /*request*/, ::schedulerpb::PutStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutStore(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetAllStores : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetAllStores() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_GetAllStores() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllStores(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetAllStoresRequest* /*request*/, ::schedulerpb::GetAllStoresResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetAllStores(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_StoreHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_StoreHeartbeat() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_StoreHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreHeartbeat(::grpc::ServerContext* /*context*/, const ::schedulerpb::StoreHeartbeatRequest* /*request*/, ::schedulerpb::StoreHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestStoreHeartbeat(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_RegionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_RegionHeartbeat() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_RegionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegionHeartbeat(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::schedulerpb::RegionHeartbeatResponse, ::schedulerpb::RegionHeartbeatRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestRegionHeartbeat(::grpc::ServerContext* context, ::grpc::ServerAsyncReaderWriter< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* stream, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncBidiStreaming(9, context, stream, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRegion() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_GetRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRegion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetPrevRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetPrevRegion() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_GetPrevRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPrevRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetPrevRegion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetRegionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetRegionByID() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_GetRegionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegionByID(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionByIDRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetRegionByID(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ScanRegions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ScanRegions() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_ScanRegions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScanRegions(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScanRegionsRequest* /*request*/, ::schedulerpb::ScanRegionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScanRegions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_AskSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_AskSplit() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_AskSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AskSplit(::grpc::ServerContext* /*context*/, const ::schedulerpb::AskSplitRequest* /*request*/, ::schedulerpb::AskSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestAskSplit(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetClusterConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetClusterConfig() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_GetClusterConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetClusterConfigRequest* /*request*/, ::schedulerpb::GetClusterConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetClusterConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_PutClusterConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_PutClusterConfig() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_PutClusterConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutClusterConfigRequest* /*request*/, ::schedulerpb::PutClusterConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestPutClusterConfig(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ScatterRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ScatterRegion() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_ScatterRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScatterRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScatterRegionRequest* /*request*/, ::schedulerpb::ScatterRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestScatterRegion(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetGCSafePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetGCSafePoint() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_GetGCSafePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetGCSafePointRequest* /*request*/, ::schedulerpb::GetGCSafePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetGCSafePoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UpdateGCSafePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UpdateGCSafePoint() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_UpdateGCSafePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::UpdateGCSafePointRequest* /*request*/, ::schedulerpb::UpdateGCSafePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUpdateGCSafePoint(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetOperator : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetOperator() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_GetOperator() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperator(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetOperatorRequest* /*request*/, ::schedulerpb::GetOperatorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetOperator(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetMembers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetMembers() {
      ::grpc::Service::experimental().MarkMethodRawCallback(0,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetMembers(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetMembers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetMembers(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetMembersRequest* /*request*/, ::schedulerpb::GetMembersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetMembers(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Tso : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Tso() {
      ::grpc::Service::experimental().MarkMethodRawCallback(1,
        new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->Tso(); }));
    }
    ~ExperimentalWithRawCallbackMethod_Tso() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Tso(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::schedulerpb::TsoResponse, ::schedulerpb::TsoRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* Tso() {
      return new ::grpc_impl::internal::UnimplementedBidiReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_Bootstrap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_Bootstrap() {
      ::grpc::Service::experimental().MarkMethodRawCallback(2,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->Bootstrap(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_Bootstrap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Bootstrap(::grpc::ServerContext* /*context*/, const ::schedulerpb::BootstrapRequest* /*request*/, ::schedulerpb::BootstrapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void Bootstrap(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_IsBootstrapped : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_IsBootstrapped() {
      ::grpc::Service::experimental().MarkMethodRawCallback(3,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->IsBootstrapped(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_IsBootstrapped() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status IsBootstrapped(::grpc::ServerContext* /*context*/, const ::schedulerpb::IsBootstrappedRequest* /*request*/, ::schedulerpb::IsBootstrappedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void IsBootstrapped(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AllocID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AllocID() {
      ::grpc::Service::experimental().MarkMethodRawCallback(4,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AllocID(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AllocID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AllocID(::grpc::ServerContext* /*context*/, const ::schedulerpb::AllocIDRequest* /*request*/, ::schedulerpb::AllocIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AllocID(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetStore() {
      ::grpc::Service::experimental().MarkMethodRawCallback(5,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetStore(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetStoreRequest* /*request*/, ::schedulerpb::GetStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetStore(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PutStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PutStore() {
      ::grpc::Service::experimental().MarkMethodRawCallback(6,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->PutStore(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_PutStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutStoreRequest* /*request*/, ::schedulerpb::PutStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void PutStore(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetAllStores : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetAllStores() {
      ::grpc::Service::experimental().MarkMethodRawCallback(7,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetAllStores(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetAllStores() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetAllStores(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetAllStoresRequest* /*request*/, ::schedulerpb::GetAllStoresResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetAllStores(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_StoreHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_StoreHeartbeat() {
      ::grpc::Service::experimental().MarkMethodRawCallback(8,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->StoreHeartbeat(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_StoreHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status StoreHeartbeat(::grpc::ServerContext* /*context*/, const ::schedulerpb::StoreHeartbeatRequest* /*request*/, ::schedulerpb::StoreHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void StoreHeartbeat(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_RegionHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_RegionHeartbeat() {
      ::grpc::Service::experimental().MarkMethodRawCallback(9,
        new ::grpc_impl::internal::CallbackBidiHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this] { return this->RegionHeartbeat(); }));
    }
    ~ExperimentalWithRawCallbackMethod_RegionHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status RegionHeartbeat(::grpc::ServerContext* /*context*/, ::grpc::ServerReaderWriter< ::schedulerpb::RegionHeartbeatResponse, ::schedulerpb::RegionHeartbeatRequest>* /*stream*/)  override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::experimental::ServerBidiReactor< ::grpc::ByteBuffer, ::grpc::ByteBuffer>* RegionHeartbeat() {
      return new ::grpc_impl::internal::UnimplementedBidiReactor<
        ::grpc::ByteBuffer, ::grpc::ByteBuffer>;}
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRegion() {
      ::grpc::Service::experimental().MarkMethodRawCallback(10,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetRegion(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRegion(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetPrevRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetPrevRegion() {
      ::grpc::Service::experimental().MarkMethodRawCallback(11,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetPrevRegion(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetPrevRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetPrevRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetPrevRegion(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetRegionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetRegionByID() {
      ::grpc::Service::experimental().MarkMethodRawCallback(12,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetRegionByID(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetRegionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetRegionByID(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionByIDRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetRegionByID(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ScanRegions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ScanRegions() {
      ::grpc::Service::experimental().MarkMethodRawCallback(13,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ScanRegions(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ScanRegions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScanRegions(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScanRegionsRequest* /*request*/, ::schedulerpb::ScanRegionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ScanRegions(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_AskSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_AskSplit() {
      ::grpc::Service::experimental().MarkMethodRawCallback(14,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->AskSplit(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_AskSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status AskSplit(::grpc::ServerContext* /*context*/, const ::schedulerpb::AskSplitRequest* /*request*/, ::schedulerpb::AskSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void AskSplit(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetClusterConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetClusterConfig() {
      ::grpc::Service::experimental().MarkMethodRawCallback(15,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetClusterConfig(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetClusterConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetClusterConfigRequest* /*request*/, ::schedulerpb::GetClusterConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetClusterConfig(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_PutClusterConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_PutClusterConfig() {
      ::grpc::Service::experimental().MarkMethodRawCallback(16,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->PutClusterConfig(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_PutClusterConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status PutClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutClusterConfigRequest* /*request*/, ::schedulerpb::PutClusterConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void PutClusterConfig(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_ScatterRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_ScatterRegion() {
      ::grpc::Service::experimental().MarkMethodRawCallback(17,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->ScatterRegion(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_ScatterRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ScatterRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScatterRegionRequest* /*request*/, ::schedulerpb::ScatterRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void ScatterRegion(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetGCSafePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetGCSafePoint() {
      ::grpc::Service::experimental().MarkMethodRawCallback(18,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetGCSafePoint(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetGCSafePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetGCSafePointRequest* /*request*/, ::schedulerpb::GetGCSafePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetGCSafePoint(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_UpdateGCSafePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_UpdateGCSafePoint() {
      ::grpc::Service::experimental().MarkMethodRawCallback(19,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->UpdateGCSafePoint(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_UpdateGCSafePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UpdateGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::UpdateGCSafePointRequest* /*request*/, ::schedulerpb::UpdateGCSafePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void UpdateGCSafePoint(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class ExperimentalWithRawCallbackMethod_GetOperator : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    ExperimentalWithRawCallbackMethod_GetOperator() {
      ::grpc::Service::experimental().MarkMethodRawCallback(20,
        new ::grpc_impl::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
          [this](::grpc::ServerContext* context,
                 const ::grpc::ByteBuffer* request,
                 ::grpc::ByteBuffer* response,
                 ::grpc::experimental::ServerCallbackRpcController* controller) {
                   this->GetOperator(context, request, response, controller);
                 }));
    }
    ~ExperimentalWithRawCallbackMethod_GetOperator() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetOperator(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetOperatorRequest* /*request*/, ::schedulerpb::GetOperatorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual void GetOperator(::grpc::ServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/, ::grpc::experimental::ServerCallbackRpcController* controller) { controller->Finish(::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "")); }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetMembers : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetMembers() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::GetMembersRequest, ::schedulerpb::GetMembersResponse>(std::bind(&WithStreamedUnaryMethod_GetMembers<BaseClass>::StreamedGetMembers, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetMembers() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetMembers(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetMembersRequest* /*request*/, ::schedulerpb::GetMembersResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetMembers(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::GetMembersRequest,::schedulerpb::GetMembersResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Bootstrap : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Bootstrap() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::BootstrapRequest, ::schedulerpb::BootstrapResponse>(std::bind(&WithStreamedUnaryMethod_Bootstrap<BaseClass>::StreamedBootstrap, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_Bootstrap() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Bootstrap(::grpc::ServerContext* /*context*/, const ::schedulerpb::BootstrapRequest* /*request*/, ::schedulerpb::BootstrapResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedBootstrap(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::BootstrapRequest,::schedulerpb::BootstrapResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_IsBootstrapped : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_IsBootstrapped() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::IsBootstrappedRequest, ::schedulerpb::IsBootstrappedResponse>(std::bind(&WithStreamedUnaryMethod_IsBootstrapped<BaseClass>::StreamedIsBootstrapped, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_IsBootstrapped() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status IsBootstrapped(::grpc::ServerContext* /*context*/, const ::schedulerpb::IsBootstrappedRequest* /*request*/, ::schedulerpb::IsBootstrappedResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedIsBootstrapped(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::IsBootstrappedRequest,::schedulerpb::IsBootstrappedResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AllocID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AllocID() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::AllocIDRequest, ::schedulerpb::AllocIDResponse>(std::bind(&WithStreamedUnaryMethod_AllocID<BaseClass>::StreamedAllocID, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AllocID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AllocID(::grpc::ServerContext* /*context*/, const ::schedulerpb::AllocIDRequest* /*request*/, ::schedulerpb::AllocIDResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAllocID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::AllocIDRequest,::schedulerpb::AllocIDResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetStore() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::GetStoreRequest, ::schedulerpb::GetStoreResponse>(std::bind(&WithStreamedUnaryMethod_GetStore<BaseClass>::StreamedGetStore, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetStoreRequest* /*request*/, ::schedulerpb::GetStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetStore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::GetStoreRequest,::schedulerpb::GetStoreResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PutStore : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PutStore() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::PutStoreRequest, ::schedulerpb::PutStoreResponse>(std::bind(&WithStreamedUnaryMethod_PutStore<BaseClass>::StreamedPutStore, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PutStore() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PutStore(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutStoreRequest* /*request*/, ::schedulerpb::PutStoreResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPutStore(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::PutStoreRequest,::schedulerpb::PutStoreResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetAllStores : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetAllStores() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::GetAllStoresRequest, ::schedulerpb::GetAllStoresResponse>(std::bind(&WithStreamedUnaryMethod_GetAllStores<BaseClass>::StreamedGetAllStores, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetAllStores() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetAllStores(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetAllStoresRequest* /*request*/, ::schedulerpb::GetAllStoresResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetAllStores(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::GetAllStoresRequest,::schedulerpb::GetAllStoresResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_StoreHeartbeat : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_StoreHeartbeat() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::StoreHeartbeatRequest, ::schedulerpb::StoreHeartbeatResponse>(std::bind(&WithStreamedUnaryMethod_StoreHeartbeat<BaseClass>::StreamedStoreHeartbeat, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_StoreHeartbeat() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status StoreHeartbeat(::grpc::ServerContext* /*context*/, const ::schedulerpb::StoreHeartbeatRequest* /*request*/, ::schedulerpb::StoreHeartbeatResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedStoreHeartbeat(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::StoreHeartbeatRequest,::schedulerpb::StoreHeartbeatResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRegion() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::GetRegionRequest, ::schedulerpb::GetRegionResponse>(std::bind(&WithStreamedUnaryMethod_GetRegion<BaseClass>::StreamedGetRegion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRegion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::GetRegionRequest,::schedulerpb::GetRegionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetPrevRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetPrevRegion() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::GetRegionRequest, ::schedulerpb::GetRegionResponse>(std::bind(&WithStreamedUnaryMethod_GetPrevRegion<BaseClass>::StreamedGetPrevRegion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetPrevRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetPrevRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetPrevRegion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::GetRegionRequest,::schedulerpb::GetRegionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetRegionByID : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetRegionByID() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::GetRegionByIDRequest, ::schedulerpb::GetRegionResponse>(std::bind(&WithStreamedUnaryMethod_GetRegionByID<BaseClass>::StreamedGetRegionByID, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetRegionByID() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetRegionByID(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetRegionByIDRequest* /*request*/, ::schedulerpb::GetRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetRegionByID(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::GetRegionByIDRequest,::schedulerpb::GetRegionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ScanRegions : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ScanRegions() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::ScanRegionsRequest, ::schedulerpb::ScanRegionsResponse>(std::bind(&WithStreamedUnaryMethod_ScanRegions<BaseClass>::StreamedScanRegions, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ScanRegions() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ScanRegions(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScanRegionsRequest* /*request*/, ::schedulerpb::ScanRegionsResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedScanRegions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::ScanRegionsRequest,::schedulerpb::ScanRegionsResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_AskSplit : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_AskSplit() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::AskSplitRequest, ::schedulerpb::AskSplitResponse>(std::bind(&WithStreamedUnaryMethod_AskSplit<BaseClass>::StreamedAskSplit, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_AskSplit() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status AskSplit(::grpc::ServerContext* /*context*/, const ::schedulerpb::AskSplitRequest* /*request*/, ::schedulerpb::AskSplitResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedAskSplit(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::AskSplitRequest,::schedulerpb::AskSplitResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetClusterConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetClusterConfig() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::GetClusterConfigRequest, ::schedulerpb::GetClusterConfigResponse>(std::bind(&WithStreamedUnaryMethod_GetClusterConfig<BaseClass>::StreamedGetClusterConfig, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetClusterConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetClusterConfigRequest* /*request*/, ::schedulerpb::GetClusterConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetClusterConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::GetClusterConfigRequest,::schedulerpb::GetClusterConfigResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_PutClusterConfig : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_PutClusterConfig() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::PutClusterConfigRequest, ::schedulerpb::PutClusterConfigResponse>(std::bind(&WithStreamedUnaryMethod_PutClusterConfig<BaseClass>::StreamedPutClusterConfig, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_PutClusterConfig() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status PutClusterConfig(::grpc::ServerContext* /*context*/, const ::schedulerpb::PutClusterConfigRequest* /*request*/, ::schedulerpb::PutClusterConfigResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedPutClusterConfig(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::PutClusterConfigRequest,::schedulerpb::PutClusterConfigResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ScatterRegion : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ScatterRegion() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::ScatterRegionRequest, ::schedulerpb::ScatterRegionResponse>(std::bind(&WithStreamedUnaryMethod_ScatterRegion<BaseClass>::StreamedScatterRegion, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_ScatterRegion() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ScatterRegion(::grpc::ServerContext* /*context*/, const ::schedulerpb::ScatterRegionRequest* /*request*/, ::schedulerpb::ScatterRegionResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedScatterRegion(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::ScatterRegionRequest,::schedulerpb::ScatterRegionResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetGCSafePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetGCSafePoint() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::GetGCSafePointRequest, ::schedulerpb::GetGCSafePointResponse>(std::bind(&WithStreamedUnaryMethod_GetGCSafePoint<BaseClass>::StreamedGetGCSafePoint, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetGCSafePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetGCSafePointRequest* /*request*/, ::schedulerpb::GetGCSafePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetGCSafePoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::GetGCSafePointRequest,::schedulerpb::GetGCSafePointResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UpdateGCSafePoint : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UpdateGCSafePoint() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::UpdateGCSafePointRequest, ::schedulerpb::UpdateGCSafePointResponse>(std::bind(&WithStreamedUnaryMethod_UpdateGCSafePoint<BaseClass>::StreamedUpdateGCSafePoint, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_UpdateGCSafePoint() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UpdateGCSafePoint(::grpc::ServerContext* /*context*/, const ::schedulerpb::UpdateGCSafePointRequest* /*request*/, ::schedulerpb::UpdateGCSafePointResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUpdateGCSafePoint(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::UpdateGCSafePointRequest,::schedulerpb::UpdateGCSafePointResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetOperator : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetOperator() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler< ::schedulerpb::GetOperatorRequest, ::schedulerpb::GetOperatorResponse>(std::bind(&WithStreamedUnaryMethod_GetOperator<BaseClass>::StreamedGetOperator, this, std::placeholders::_1, std::placeholders::_2)));
    }
    ~WithStreamedUnaryMethod_GetOperator() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetOperator(::grpc::ServerContext* /*context*/, const ::schedulerpb::GetOperatorRequest* /*request*/, ::schedulerpb::GetOperatorResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetOperator(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::schedulerpb::GetOperatorRequest,::schedulerpb::GetOperatorResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetMembers<WithStreamedUnaryMethod_Bootstrap<WithStreamedUnaryMethod_IsBootstrapped<WithStreamedUnaryMethod_AllocID<WithStreamedUnaryMethod_GetStore<WithStreamedUnaryMethod_PutStore<WithStreamedUnaryMethod_GetAllStores<WithStreamedUnaryMethod_StoreHeartbeat<WithStreamedUnaryMethod_GetRegion<WithStreamedUnaryMethod_GetPrevRegion<WithStreamedUnaryMethod_GetRegionByID<WithStreamedUnaryMethod_ScanRegions<WithStreamedUnaryMethod_AskSplit<WithStreamedUnaryMethod_GetClusterConfig<WithStreamedUnaryMethod_PutClusterConfig<WithStreamedUnaryMethod_ScatterRegion<WithStreamedUnaryMethod_GetGCSafePoint<WithStreamedUnaryMethod_UpdateGCSafePoint<WithStreamedUnaryMethod_GetOperator<Service > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  typedef Service SplitStreamedService;
  typedef WithStreamedUnaryMethod_GetMembers<WithStreamedUnaryMethod_Bootstrap<WithStreamedUnaryMethod_IsBootstrapped<WithStreamedUnaryMethod_AllocID<WithStreamedUnaryMethod_GetStore<WithStreamedUnaryMethod_PutStore<WithStreamedUnaryMethod_GetAllStores<WithStreamedUnaryMethod_StoreHeartbeat<WithStreamedUnaryMethod_GetRegion<WithStreamedUnaryMethod_GetPrevRegion<WithStreamedUnaryMethod_GetRegionByID<WithStreamedUnaryMethod_ScanRegions<WithStreamedUnaryMethod_AskSplit<WithStreamedUnaryMethod_GetClusterConfig<WithStreamedUnaryMethod_PutClusterConfig<WithStreamedUnaryMethod_ScatterRegion<WithStreamedUnaryMethod_GetGCSafePoint<WithStreamedUnaryMethod_UpdateGCSafePoint<WithStreamedUnaryMethod_GetOperator<Service > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace schedulerpb


#endif  // GRPC_schedulerpb_2eproto__INCLUDED
