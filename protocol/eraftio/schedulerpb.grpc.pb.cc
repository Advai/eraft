// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: schedulerpb.proto

#include "schedulerpb.pb.h"
#include "schedulerpb.grpc.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/channel_interface.h>
#include <grpcpp/impl/codegen/client_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/method_handler_impl.h>
#include <grpcpp/impl/codegen/rpc_service_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/sync_stream.h>
namespace schedulerpb {

static const char* Scheduler_method_names[] = {
  "/schedulerpb.Scheduler/GetMembers",
  "/schedulerpb.Scheduler/Tso",
  "/schedulerpb.Scheduler/Bootstrap",
  "/schedulerpb.Scheduler/IsBootstrapped",
  "/schedulerpb.Scheduler/AllocID",
  "/schedulerpb.Scheduler/GetStore",
  "/schedulerpb.Scheduler/PutStore",
  "/schedulerpb.Scheduler/GetAllStores",
  "/schedulerpb.Scheduler/StoreHeartbeat",
  "/schedulerpb.Scheduler/RegionHeartbeat",
  "/schedulerpb.Scheduler/GetRegion",
  "/schedulerpb.Scheduler/GetPrevRegion",
  "/schedulerpb.Scheduler/GetRegionByID",
  "/schedulerpb.Scheduler/ScanRegions",
  "/schedulerpb.Scheduler/AskSplit",
  "/schedulerpb.Scheduler/GetClusterConfig",
  "/schedulerpb.Scheduler/PutClusterConfig",
  "/schedulerpb.Scheduler/ScatterRegion",
  "/schedulerpb.Scheduler/GetGCSafePoint",
  "/schedulerpb.Scheduler/UpdateGCSafePoint",
  "/schedulerpb.Scheduler/GetOperator",
};

std::unique_ptr< Scheduler::Stub> Scheduler::NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options) {
  (void)options;
  std::unique_ptr< Scheduler::Stub> stub(new Scheduler::Stub(channel));
  return stub;
}

Scheduler::Stub::Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel)
  : channel_(channel), rpcmethod_GetMembers_(Scheduler_method_names[0], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_Tso_(Scheduler_method_names[1], ::grpc::internal::RpcMethod::BIDI_STREAMING, channel)
  , rpcmethod_Bootstrap_(Scheduler_method_names[2], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_IsBootstrapped_(Scheduler_method_names[3], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_AllocID_(Scheduler_method_names[4], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetStore_(Scheduler_method_names[5], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_PutStore_(Scheduler_method_names[6], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetAllStores_(Scheduler_method_names[7], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_StoreHeartbeat_(Scheduler_method_names[8], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_RegionHeartbeat_(Scheduler_method_names[9], ::grpc::internal::RpcMethod::BIDI_STREAMING, channel)
  , rpcmethod_GetRegion_(Scheduler_method_names[10], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetPrevRegion_(Scheduler_method_names[11], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetRegionByID_(Scheduler_method_names[12], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ScanRegions_(Scheduler_method_names[13], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_AskSplit_(Scheduler_method_names[14], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetClusterConfig_(Scheduler_method_names[15], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_PutClusterConfig_(Scheduler_method_names[16], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_ScatterRegion_(Scheduler_method_names[17], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetGCSafePoint_(Scheduler_method_names[18], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_UpdateGCSafePoint_(Scheduler_method_names[19], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  , rpcmethod_GetOperator_(Scheduler_method_names[20], ::grpc::internal::RpcMethod::NORMAL_RPC, channel)
  {}

::grpc::Status Scheduler::Stub::GetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::schedulerpb::GetMembersResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetMembers_, context, request, response);
}

void Scheduler::Stub::experimental_async::GetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest* request, ::schedulerpb::GetMembersResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetMembers_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetMembers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetMembersResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetMembers_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetMembers(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest* request, ::schedulerpb::GetMembersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetMembers_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::GetMembers(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetMembersResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetMembers_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetMembersResponse>* Scheduler::Stub::AsyncGetMembersRaw(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetMembersResponse>::Create(channel_.get(), cq, rpcmethod_GetMembers_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetMembersResponse>* Scheduler::Stub::PrepareAsyncGetMembersRaw(::grpc::ClientContext* context, const ::schedulerpb::GetMembersRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetMembersResponse>::Create(channel_.get(), cq, rpcmethod_GetMembers_, context, request, false);
}

::grpc::ClientReaderWriter< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>* Scheduler::Stub::TsoRaw(::grpc::ClientContext* context) {
  return ::grpc_impl::internal::ClientReaderWriterFactory< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>::Create(channel_.get(), rpcmethod_Tso_, context);
}

void Scheduler::Stub::experimental_async::Tso(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::schedulerpb::TsoRequest,::schedulerpb::TsoResponse>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderWriterFactory< ::schedulerpb::TsoRequest,::schedulerpb::TsoResponse>::Create(stub_->channel_.get(), stub_->rpcmethod_Tso_, context, reactor);
}

::grpc::ClientAsyncReaderWriter< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>* Scheduler::Stub::AsyncTsoRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderWriterFactory< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>::Create(channel_.get(), cq, rpcmethod_Tso_, context, true, tag);
}

::grpc::ClientAsyncReaderWriter< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>* Scheduler::Stub::PrepareAsyncTsoRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderWriterFactory< ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>::Create(channel_.get(), cq, rpcmethod_Tso_, context, false, nullptr);
}

::grpc::Status Scheduler::Stub::Bootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::schedulerpb::BootstrapResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_Bootstrap_, context, request, response);
}

void Scheduler::Stub::experimental_async::Bootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest* request, ::schedulerpb::BootstrapResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Bootstrap_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::Bootstrap(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::BootstrapResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_Bootstrap_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::Bootstrap(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest* request, ::schedulerpb::BootstrapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Bootstrap_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::Bootstrap(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::BootstrapResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_Bootstrap_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::BootstrapResponse>* Scheduler::Stub::AsyncBootstrapRaw(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::BootstrapResponse>::Create(channel_.get(), cq, rpcmethod_Bootstrap_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::BootstrapResponse>* Scheduler::Stub::PrepareAsyncBootstrapRaw(::grpc::ClientContext* context, const ::schedulerpb::BootstrapRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::BootstrapResponse>::Create(channel_.get(), cq, rpcmethod_Bootstrap_, context, request, false);
}

::grpc::Status Scheduler::Stub::IsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::schedulerpb::IsBootstrappedResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_IsBootstrapped_, context, request, response);
}

void Scheduler::Stub::experimental_async::IsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest* request, ::schedulerpb::IsBootstrappedResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_IsBootstrapped_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::IsBootstrapped(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::IsBootstrappedResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_IsBootstrapped_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::IsBootstrapped(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest* request, ::schedulerpb::IsBootstrappedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_IsBootstrapped_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::IsBootstrapped(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::IsBootstrappedResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_IsBootstrapped_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::IsBootstrappedResponse>* Scheduler::Stub::AsyncIsBootstrappedRaw(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::IsBootstrappedResponse>::Create(channel_.get(), cq, rpcmethod_IsBootstrapped_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::IsBootstrappedResponse>* Scheduler::Stub::PrepareAsyncIsBootstrappedRaw(::grpc::ClientContext* context, const ::schedulerpb::IsBootstrappedRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::IsBootstrappedResponse>::Create(channel_.get(), cq, rpcmethod_IsBootstrapped_, context, request, false);
}

::grpc::Status Scheduler::Stub::AllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::schedulerpb::AllocIDResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_AllocID_, context, request, response);
}

void Scheduler::Stub::experimental_async::AllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest* request, ::schedulerpb::AllocIDResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_AllocID_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::AllocID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::AllocIDResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_AllocID_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::AllocID(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest* request, ::schedulerpb::AllocIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_AllocID_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::AllocID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::AllocIDResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_AllocID_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::AllocIDResponse>* Scheduler::Stub::AsyncAllocIDRaw(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::AllocIDResponse>::Create(channel_.get(), cq, rpcmethod_AllocID_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::AllocIDResponse>* Scheduler::Stub::PrepareAsyncAllocIDRaw(::grpc::ClientContext* context, const ::schedulerpb::AllocIDRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::AllocIDResponse>::Create(channel_.get(), cq, rpcmethod_AllocID_, context, request, false);
}

::grpc::Status Scheduler::Stub::GetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::schedulerpb::GetStoreResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetStore_, context, request, response);
}

void Scheduler::Stub::experimental_async::GetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest* request, ::schedulerpb::GetStoreResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetStore_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetStore(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetStoreResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetStore_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetStore(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest* request, ::schedulerpb::GetStoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetStore_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::GetStore(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetStoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetStore_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetStoreResponse>* Scheduler::Stub::AsyncGetStoreRaw(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetStoreResponse>::Create(channel_.get(), cq, rpcmethod_GetStore_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetStoreResponse>* Scheduler::Stub::PrepareAsyncGetStoreRaw(::grpc::ClientContext* context, const ::schedulerpb::GetStoreRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetStoreResponse>::Create(channel_.get(), cq, rpcmethod_GetStore_, context, request, false);
}

::grpc::Status Scheduler::Stub::PutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::schedulerpb::PutStoreResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_PutStore_, context, request, response);
}

void Scheduler::Stub::experimental_async::PutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest* request, ::schedulerpb::PutStoreResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_PutStore_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::PutStore(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::PutStoreResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_PutStore_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::PutStore(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest* request, ::schedulerpb::PutStoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_PutStore_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::PutStore(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::PutStoreResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_PutStore_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::PutStoreResponse>* Scheduler::Stub::AsyncPutStoreRaw(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::PutStoreResponse>::Create(channel_.get(), cq, rpcmethod_PutStore_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::PutStoreResponse>* Scheduler::Stub::PrepareAsyncPutStoreRaw(::grpc::ClientContext* context, const ::schedulerpb::PutStoreRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::PutStoreResponse>::Create(channel_.get(), cq, rpcmethod_PutStore_, context, request, false);
}

::grpc::Status Scheduler::Stub::GetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::schedulerpb::GetAllStoresResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetAllStores_, context, request, response);
}

void Scheduler::Stub::experimental_async::GetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest* request, ::schedulerpb::GetAllStoresResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAllStores_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetAllStores(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetAllStoresResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetAllStores_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetAllStores(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest* request, ::schedulerpb::GetAllStoresResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAllStores_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::GetAllStores(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetAllStoresResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetAllStores_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetAllStoresResponse>* Scheduler::Stub::AsyncGetAllStoresRaw(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetAllStoresResponse>::Create(channel_.get(), cq, rpcmethod_GetAllStores_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetAllStoresResponse>* Scheduler::Stub::PrepareAsyncGetAllStoresRaw(::grpc::ClientContext* context, const ::schedulerpb::GetAllStoresRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetAllStoresResponse>::Create(channel_.get(), cq, rpcmethod_GetAllStores_, context, request, false);
}

::grpc::Status Scheduler::Stub::StoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::schedulerpb::StoreHeartbeatResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_StoreHeartbeat_, context, request, response);
}

void Scheduler::Stub::experimental_async::StoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest* request, ::schedulerpb::StoreHeartbeatResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StoreHeartbeat_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::StoreHeartbeat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::StoreHeartbeatResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_StoreHeartbeat_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::StoreHeartbeat(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest* request, ::schedulerpb::StoreHeartbeatResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StoreHeartbeat_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::StoreHeartbeat(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::StoreHeartbeatResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_StoreHeartbeat_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::StoreHeartbeatResponse>* Scheduler::Stub::AsyncStoreHeartbeatRaw(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::StoreHeartbeatResponse>::Create(channel_.get(), cq, rpcmethod_StoreHeartbeat_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::StoreHeartbeatResponse>* Scheduler::Stub::PrepareAsyncStoreHeartbeatRaw(::grpc::ClientContext* context, const ::schedulerpb::StoreHeartbeatRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::StoreHeartbeatResponse>::Create(channel_.get(), cq, rpcmethod_StoreHeartbeat_, context, request, false);
}

::grpc::ClientReaderWriter< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>* Scheduler::Stub::RegionHeartbeatRaw(::grpc::ClientContext* context) {
  return ::grpc_impl::internal::ClientReaderWriterFactory< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>::Create(channel_.get(), rpcmethod_RegionHeartbeat_, context);
}

void Scheduler::Stub::experimental_async::RegionHeartbeat(::grpc::ClientContext* context, ::grpc::experimental::ClientBidiReactor< ::schedulerpb::RegionHeartbeatRequest,::schedulerpb::RegionHeartbeatResponse>* reactor) {
  ::grpc_impl::internal::ClientCallbackReaderWriterFactory< ::schedulerpb::RegionHeartbeatRequest,::schedulerpb::RegionHeartbeatResponse>::Create(stub_->channel_.get(), stub_->rpcmethod_RegionHeartbeat_, context, reactor);
}

::grpc::ClientAsyncReaderWriter< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>* Scheduler::Stub::AsyncRegionHeartbeatRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq, void* tag) {
  return ::grpc_impl::internal::ClientAsyncReaderWriterFactory< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>::Create(channel_.get(), cq, rpcmethod_RegionHeartbeat_, context, true, tag);
}

::grpc::ClientAsyncReaderWriter< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>* Scheduler::Stub::PrepareAsyncRegionHeartbeatRaw(::grpc::ClientContext* context, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncReaderWriterFactory< ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>::Create(channel_.get(), cq, rpcmethod_RegionHeartbeat_, context, false, nullptr);
}

::grpc::Status Scheduler::Stub::GetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::schedulerpb::GetRegionResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetRegion_, context, request, response);
}

void Scheduler::Stub::experimental_async::GetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetRegion_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetRegion_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetRegion_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::GetRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetRegion_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>* Scheduler::Stub::AsyncGetRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetRegionResponse>::Create(channel_.get(), cq, rpcmethod_GetRegion_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>* Scheduler::Stub::PrepareAsyncGetRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetRegionResponse>::Create(channel_.get(), cq, rpcmethod_GetRegion_, context, request, false);
}

::grpc::Status Scheduler::Stub::GetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::schedulerpb::GetRegionResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetPrevRegion_, context, request, response);
}

void Scheduler::Stub::experimental_async::GetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetPrevRegion_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetPrevRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetPrevRegion_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetPrevRegion(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetPrevRegion_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::GetPrevRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetPrevRegion_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>* Scheduler::Stub::AsyncGetPrevRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetRegionResponse>::Create(channel_.get(), cq, rpcmethod_GetPrevRegion_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>* Scheduler::Stub::PrepareAsyncGetPrevRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetRegionResponse>::Create(channel_.get(), cq, rpcmethod_GetPrevRegion_, context, request, false);
}

::grpc::Status Scheduler::Stub::GetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::schedulerpb::GetRegionResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetRegionByID_, context, request, response);
}

void Scheduler::Stub::experimental_async::GetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetRegionByID_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetRegionByID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetRegionByID_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetRegionByID(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetRegionByID_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::GetRegionByID(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetRegionByID_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>* Scheduler::Stub::AsyncGetRegionByIDRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetRegionResponse>::Create(channel_.get(), cq, rpcmethod_GetRegionByID_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetRegionResponse>* Scheduler::Stub::PrepareAsyncGetRegionByIDRaw(::grpc::ClientContext* context, const ::schedulerpb::GetRegionByIDRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetRegionResponse>::Create(channel_.get(), cq, rpcmethod_GetRegionByID_, context, request, false);
}

::grpc::Status Scheduler::Stub::ScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::schedulerpb::ScanRegionsResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ScanRegions_, context, request, response);
}

void Scheduler::Stub::experimental_async::ScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest* request, ::schedulerpb::ScanRegionsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ScanRegions_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::ScanRegions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::ScanRegionsResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ScanRegions_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::ScanRegions(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest* request, ::schedulerpb::ScanRegionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ScanRegions_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::ScanRegions(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::ScanRegionsResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ScanRegions_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::ScanRegionsResponse>* Scheduler::Stub::AsyncScanRegionsRaw(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::ScanRegionsResponse>::Create(channel_.get(), cq, rpcmethod_ScanRegions_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::ScanRegionsResponse>* Scheduler::Stub::PrepareAsyncScanRegionsRaw(::grpc::ClientContext* context, const ::schedulerpb::ScanRegionsRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::ScanRegionsResponse>::Create(channel_.get(), cq, rpcmethod_ScanRegions_, context, request, false);
}

::grpc::Status Scheduler::Stub::AskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::schedulerpb::AskSplitResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_AskSplit_, context, request, response);
}

void Scheduler::Stub::experimental_async::AskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest* request, ::schedulerpb::AskSplitResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_AskSplit_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::AskSplit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::AskSplitResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_AskSplit_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::AskSplit(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest* request, ::schedulerpb::AskSplitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_AskSplit_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::AskSplit(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::AskSplitResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_AskSplit_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::AskSplitResponse>* Scheduler::Stub::AsyncAskSplitRaw(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::AskSplitResponse>::Create(channel_.get(), cq, rpcmethod_AskSplit_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::AskSplitResponse>* Scheduler::Stub::PrepareAsyncAskSplitRaw(::grpc::ClientContext* context, const ::schedulerpb::AskSplitRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::AskSplitResponse>::Create(channel_.get(), cq, rpcmethod_AskSplit_, context, request, false);
}

::grpc::Status Scheduler::Stub::GetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::schedulerpb::GetClusterConfigResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetClusterConfig_, context, request, response);
}

void Scheduler::Stub::experimental_async::GetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest* request, ::schedulerpb::GetClusterConfigResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetClusterConfig_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetClusterConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetClusterConfigResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetClusterConfig_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest* request, ::schedulerpb::GetClusterConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetClusterConfig_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::GetClusterConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetClusterConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetClusterConfig_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetClusterConfigResponse>* Scheduler::Stub::AsyncGetClusterConfigRaw(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetClusterConfigResponse>::Create(channel_.get(), cq, rpcmethod_GetClusterConfig_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetClusterConfigResponse>* Scheduler::Stub::PrepareAsyncGetClusterConfigRaw(::grpc::ClientContext* context, const ::schedulerpb::GetClusterConfigRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetClusterConfigResponse>::Create(channel_.get(), cq, rpcmethod_GetClusterConfig_, context, request, false);
}

::grpc::Status Scheduler::Stub::PutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::schedulerpb::PutClusterConfigResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_PutClusterConfig_, context, request, response);
}

void Scheduler::Stub::experimental_async::PutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest* request, ::schedulerpb::PutClusterConfigResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_PutClusterConfig_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::PutClusterConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::PutClusterConfigResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_PutClusterConfig_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::PutClusterConfig(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest* request, ::schedulerpb::PutClusterConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_PutClusterConfig_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::PutClusterConfig(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::PutClusterConfigResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_PutClusterConfig_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::PutClusterConfigResponse>* Scheduler::Stub::AsyncPutClusterConfigRaw(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::PutClusterConfigResponse>::Create(channel_.get(), cq, rpcmethod_PutClusterConfig_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::PutClusterConfigResponse>* Scheduler::Stub::PrepareAsyncPutClusterConfigRaw(::grpc::ClientContext* context, const ::schedulerpb::PutClusterConfigRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::PutClusterConfigResponse>::Create(channel_.get(), cq, rpcmethod_PutClusterConfig_, context, request, false);
}

::grpc::Status Scheduler::Stub::ScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::schedulerpb::ScatterRegionResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_ScatterRegion_, context, request, response);
}

void Scheduler::Stub::experimental_async::ScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest* request, ::schedulerpb::ScatterRegionResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ScatterRegion_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::ScatterRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::ScatterRegionResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_ScatterRegion_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::ScatterRegion(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest* request, ::schedulerpb::ScatterRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ScatterRegion_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::ScatterRegion(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::ScatterRegionResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_ScatterRegion_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::ScatterRegionResponse>* Scheduler::Stub::AsyncScatterRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::ScatterRegionResponse>::Create(channel_.get(), cq, rpcmethod_ScatterRegion_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::ScatterRegionResponse>* Scheduler::Stub::PrepareAsyncScatterRegionRaw(::grpc::ClientContext* context, const ::schedulerpb::ScatterRegionRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::ScatterRegionResponse>::Create(channel_.get(), cq, rpcmethod_ScatterRegion_, context, request, false);
}

::grpc::Status Scheduler::Stub::GetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::schedulerpb::GetGCSafePointResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetGCSafePoint_, context, request, response);
}

void Scheduler::Stub::experimental_async::GetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest* request, ::schedulerpb::GetGCSafePointResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetGCSafePoint_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetGCSafePoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetGCSafePointResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetGCSafePoint_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest* request, ::schedulerpb::GetGCSafePointResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetGCSafePoint_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::GetGCSafePoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetGCSafePointResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetGCSafePoint_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetGCSafePointResponse>* Scheduler::Stub::AsyncGetGCSafePointRaw(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetGCSafePointResponse>::Create(channel_.get(), cq, rpcmethod_GetGCSafePoint_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetGCSafePointResponse>* Scheduler::Stub::PrepareAsyncGetGCSafePointRaw(::grpc::ClientContext* context, const ::schedulerpb::GetGCSafePointRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetGCSafePointResponse>::Create(channel_.get(), cq, rpcmethod_GetGCSafePoint_, context, request, false);
}

::grpc::Status Scheduler::Stub::UpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::schedulerpb::UpdateGCSafePointResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_UpdateGCSafePoint_, context, request, response);
}

void Scheduler::Stub::experimental_async::UpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest* request, ::schedulerpb::UpdateGCSafePointResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_UpdateGCSafePoint_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::UpdateGCSafePoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::UpdateGCSafePointResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_UpdateGCSafePoint_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::UpdateGCSafePoint(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest* request, ::schedulerpb::UpdateGCSafePointResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_UpdateGCSafePoint_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::UpdateGCSafePoint(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::UpdateGCSafePointResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_UpdateGCSafePoint_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::UpdateGCSafePointResponse>* Scheduler::Stub::AsyncUpdateGCSafePointRaw(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::UpdateGCSafePointResponse>::Create(channel_.get(), cq, rpcmethod_UpdateGCSafePoint_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::UpdateGCSafePointResponse>* Scheduler::Stub::PrepareAsyncUpdateGCSafePointRaw(::grpc::ClientContext* context, const ::schedulerpb::UpdateGCSafePointRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::UpdateGCSafePointResponse>::Create(channel_.get(), cq, rpcmethod_UpdateGCSafePoint_, context, request, false);
}

::grpc::Status Scheduler::Stub::GetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::schedulerpb::GetOperatorResponse* response) {
  return ::grpc::internal::BlockingUnaryCall(channel_.get(), rpcmethod_GetOperator_, context, request, response);
}

void Scheduler::Stub::experimental_async::GetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest* request, ::schedulerpb::GetOperatorResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetOperator_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetOperator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetOperatorResponse* response, std::function<void(::grpc::Status)> f) {
  ::grpc_impl::internal::CallbackUnaryCall(stub_->channel_.get(), stub_->rpcmethod_GetOperator_, context, request, response, std::move(f));
}

void Scheduler::Stub::experimental_async::GetOperator(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest* request, ::schedulerpb::GetOperatorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetOperator_, context, request, response, reactor);
}

void Scheduler::Stub::experimental_async::GetOperator(::grpc::ClientContext* context, const ::grpc::ByteBuffer* request, ::schedulerpb::GetOperatorResponse* response, ::grpc::experimental::ClientUnaryReactor* reactor) {
  ::grpc_impl::internal::ClientCallbackUnaryFactory::Create(stub_->channel_.get(), stub_->rpcmethod_GetOperator_, context, request, response, reactor);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetOperatorResponse>* Scheduler::Stub::AsyncGetOperatorRaw(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetOperatorResponse>::Create(channel_.get(), cq, rpcmethod_GetOperator_, context, request, true);
}

::grpc::ClientAsyncResponseReader< ::schedulerpb::GetOperatorResponse>* Scheduler::Stub::PrepareAsyncGetOperatorRaw(::grpc::ClientContext* context, const ::schedulerpb::GetOperatorRequest& request, ::grpc::CompletionQueue* cq) {
  return ::grpc_impl::internal::ClientAsyncResponseReaderFactory< ::schedulerpb::GetOperatorResponse>::Create(channel_.get(), cq, rpcmethod_GetOperator_, context, request, false);
}

Scheduler::Service::Service() {
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[0],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::GetMembersRequest, ::schedulerpb::GetMembersResponse>(
          std::mem_fn(&Scheduler::Service::GetMembers), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[1],
      ::grpc::internal::RpcMethod::BIDI_STREAMING,
      new ::grpc::internal::BidiStreamingHandler< Scheduler::Service, ::schedulerpb::TsoRequest, ::schedulerpb::TsoResponse>(
          std::mem_fn(&Scheduler::Service::Tso), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[2],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::BootstrapRequest, ::schedulerpb::BootstrapResponse>(
          std::mem_fn(&Scheduler::Service::Bootstrap), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[3],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::IsBootstrappedRequest, ::schedulerpb::IsBootstrappedResponse>(
          std::mem_fn(&Scheduler::Service::IsBootstrapped), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[4],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::AllocIDRequest, ::schedulerpb::AllocIDResponse>(
          std::mem_fn(&Scheduler::Service::AllocID), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[5],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::GetStoreRequest, ::schedulerpb::GetStoreResponse>(
          std::mem_fn(&Scheduler::Service::GetStore), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[6],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::PutStoreRequest, ::schedulerpb::PutStoreResponse>(
          std::mem_fn(&Scheduler::Service::PutStore), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[7],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::GetAllStoresRequest, ::schedulerpb::GetAllStoresResponse>(
          std::mem_fn(&Scheduler::Service::GetAllStores), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[8],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::StoreHeartbeatRequest, ::schedulerpb::StoreHeartbeatResponse>(
          std::mem_fn(&Scheduler::Service::StoreHeartbeat), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[9],
      ::grpc::internal::RpcMethod::BIDI_STREAMING,
      new ::grpc::internal::BidiStreamingHandler< Scheduler::Service, ::schedulerpb::RegionHeartbeatRequest, ::schedulerpb::RegionHeartbeatResponse>(
          std::mem_fn(&Scheduler::Service::RegionHeartbeat), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[10],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::GetRegionRequest, ::schedulerpb::GetRegionResponse>(
          std::mem_fn(&Scheduler::Service::GetRegion), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[11],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::GetRegionRequest, ::schedulerpb::GetRegionResponse>(
          std::mem_fn(&Scheduler::Service::GetPrevRegion), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[12],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::GetRegionByIDRequest, ::schedulerpb::GetRegionResponse>(
          std::mem_fn(&Scheduler::Service::GetRegionByID), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[13],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::ScanRegionsRequest, ::schedulerpb::ScanRegionsResponse>(
          std::mem_fn(&Scheduler::Service::ScanRegions), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[14],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::AskSplitRequest, ::schedulerpb::AskSplitResponse>(
          std::mem_fn(&Scheduler::Service::AskSplit), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[15],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::GetClusterConfigRequest, ::schedulerpb::GetClusterConfigResponse>(
          std::mem_fn(&Scheduler::Service::GetClusterConfig), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[16],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::PutClusterConfigRequest, ::schedulerpb::PutClusterConfigResponse>(
          std::mem_fn(&Scheduler::Service::PutClusterConfig), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[17],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::ScatterRegionRequest, ::schedulerpb::ScatterRegionResponse>(
          std::mem_fn(&Scheduler::Service::ScatterRegion), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[18],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::GetGCSafePointRequest, ::schedulerpb::GetGCSafePointResponse>(
          std::mem_fn(&Scheduler::Service::GetGCSafePoint), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[19],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::UpdateGCSafePointRequest, ::schedulerpb::UpdateGCSafePointResponse>(
          std::mem_fn(&Scheduler::Service::UpdateGCSafePoint), this)));
  AddMethod(new ::grpc::internal::RpcServiceMethod(
      Scheduler_method_names[20],
      ::grpc::internal::RpcMethod::NORMAL_RPC,
      new ::grpc::internal::RpcMethodHandler< Scheduler::Service, ::schedulerpb::GetOperatorRequest, ::schedulerpb::GetOperatorResponse>(
          std::mem_fn(&Scheduler::Service::GetOperator), this)));
}

Scheduler::Service::~Service() {
}

::grpc::Status Scheduler::Service::GetMembers(::grpc::ServerContext* context, const ::schedulerpb::GetMembersRequest* request, ::schedulerpb::GetMembersResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::Tso(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::schedulerpb::TsoResponse, ::schedulerpb::TsoRequest>* stream) {
  (void) context;
  (void) stream;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::Bootstrap(::grpc::ServerContext* context, const ::schedulerpb::BootstrapRequest* request, ::schedulerpb::BootstrapResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::IsBootstrapped(::grpc::ServerContext* context, const ::schedulerpb::IsBootstrappedRequest* request, ::schedulerpb::IsBootstrappedResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::AllocID(::grpc::ServerContext* context, const ::schedulerpb::AllocIDRequest* request, ::schedulerpb::AllocIDResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::GetStore(::grpc::ServerContext* context, const ::schedulerpb::GetStoreRequest* request, ::schedulerpb::GetStoreResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::PutStore(::grpc::ServerContext* context, const ::schedulerpb::PutStoreRequest* request, ::schedulerpb::PutStoreResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::GetAllStores(::grpc::ServerContext* context, const ::schedulerpb::GetAllStoresRequest* request, ::schedulerpb::GetAllStoresResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::StoreHeartbeat(::grpc::ServerContext* context, const ::schedulerpb::StoreHeartbeatRequest* request, ::schedulerpb::StoreHeartbeatResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::RegionHeartbeat(::grpc::ServerContext* context, ::grpc::ServerReaderWriter< ::schedulerpb::RegionHeartbeatResponse, ::schedulerpb::RegionHeartbeatRequest>* stream) {
  (void) context;
  (void) stream;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::GetRegion(::grpc::ServerContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::GetPrevRegion(::grpc::ServerContext* context, const ::schedulerpb::GetRegionRequest* request, ::schedulerpb::GetRegionResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::GetRegionByID(::grpc::ServerContext* context, const ::schedulerpb::GetRegionByIDRequest* request, ::schedulerpb::GetRegionResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::ScanRegions(::grpc::ServerContext* context, const ::schedulerpb::ScanRegionsRequest* request, ::schedulerpb::ScanRegionsResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::AskSplit(::grpc::ServerContext* context, const ::schedulerpb::AskSplitRequest* request, ::schedulerpb::AskSplitResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::GetClusterConfig(::grpc::ServerContext* context, const ::schedulerpb::GetClusterConfigRequest* request, ::schedulerpb::GetClusterConfigResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::PutClusterConfig(::grpc::ServerContext* context, const ::schedulerpb::PutClusterConfigRequest* request, ::schedulerpb::PutClusterConfigResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::ScatterRegion(::grpc::ServerContext* context, const ::schedulerpb::ScatterRegionRequest* request, ::schedulerpb::ScatterRegionResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::GetGCSafePoint(::grpc::ServerContext* context, const ::schedulerpb::GetGCSafePointRequest* request, ::schedulerpb::GetGCSafePointResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::UpdateGCSafePoint(::grpc::ServerContext* context, const ::schedulerpb::UpdateGCSafePointRequest* request, ::schedulerpb::UpdateGCSafePointResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}

::grpc::Status Scheduler::Service::GetOperator(::grpc::ServerContext* context, const ::schedulerpb::GetOperatorRequest* request, ::schedulerpb::GetOperatorResponse* response) {
  (void) context;
  (void) request;
  (void) response;
  return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
}


}  // namespace schedulerpb

