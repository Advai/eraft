#ifndef ERAFT_KV_META_H_
#define ERAFT_KV_META_H_

#include <vector>
#include <stdint.h>
#include <cassert>

#include <Kv/utils.h>
#include <eraftio/raft_serverpb.pb.h>
#include <eraftio/eraftpb.pb.h>
#include <rocksdb/db.h>

namespace kvserver
{

const std::vector<uint8_t> kLocalPrefix = { 0x01 };

const std::vector<uint8_t> kRegionRaftPrefix = { 0x02 };

const std::vector<uint8_t> kRegionMetaPrefix = { 0x03 };

const uint8_t kRegionRaftPrefixLen = 11;

const uint8_t kRegionRaftLogLen = 19;

const std::vector<uint8_t> kRaftLogSuffix = { 0x01 };

const std::vector<uint8_t> kRaftStateSuffix = { 0x02 };

const std::vector<uint8_t> kApplyStateSuffix = { 0x03 };

const std::vector<uint8_t> kRegionStateSuffix = { 0x01 };

const std::vector<uint8_t> MinKey = {};

const std::vector<uint8_t> MaxKey = { 255 };

const std::vector<uint8_t> LocalMinKey = { 0x01 };

const std::vector<uint8_t> LocalMaxKey = { 0x02 };

const std::vector<uint8_t> RegionMetaMinKey = { 0x01, 0x03 };

const std::vector<uint8_t> RegionMetaMaxKey = { 0x01, 0x04 };

const std::vector<uint8_t> PrepareBootstrapKey = { 0x01, 0x01 };

const std::vector<uint8_t> StoreIdentKey = { 0x01, 0x02 };

//
//  CF defines
//
const std::string CfDefault = "default";
const std::string CfWrite = "write";
const std::string CfLock = "lock";

const std::vector<std::string> CFs = { CfDefault, CfWrite, CfLock };

//
// RegionPrefix: kLocalPrefix + kRegionRaftPrefix + regionID + suffix
//
static std::vector<uint8_t> MakeRegionPrefix(uint64_t regionID, std::vector<uint8_t> suffix) 
{
    std::vector<uint8_t> packet;
    packet.insert(packet.begin(), kLocalPrefix.begin(), kLocalPrefix.end());
    packet.insert(packet.end(), kRegionRaftPrefix.begin(), kRegionRaftPrefix.end());
    WriteU64(packet, regionID);
    packet.insert(packet.end(), suffix.begin(), suffix.end());
    return packet;
}

//
// RegionKey: kLocalPrefix + kRegionRaftPrefix + regionID + suffix + subID
//

static std::vector<uint8_t> MakeRegionKey(uint64_t regionID, std::vector<uint8_t> suffix, uint64_t subID)
{
    std::vector<uint8_t> packet;
    packet.insert(packet.begin(), kLocalPrefix.begin(), kLocalPrefix.end());
    packet.insert(packet.end(), kRegionRaftPrefix.begin(), kRegionRaftPrefix.end());
    WriteU64(packet, regionID);
    packet.insert(packet.end(), suffix.begin(), suffix.end());
    WriteU64(packet, subID);
    return packet;
}

//
//  RegionRaftPrefixKey: kLocalPrefix + kRegionRaftPrefix + regionID
//

static std::vector<uint8_t> RegionRaftPrefixKey(uint64_t regionID)
{
    std::vector<uint8_t> packet;
    packet.insert(packet.begin(), kLocalPrefix.begin(), kLocalPrefix.end());
    packet.insert(packet.end(), kRegionRaftPrefix.begin(), kRegionRaftPrefix.end());
    WriteU64(packet, regionID);
    return packet;
}

static std::vector<uint8_t> RaftLogKey(uint64_t regionID, uint64_t index)
{
    return MakeRegionKey(regionID, kRaftLogSuffix, index);
}

static std::vector<uint8_t> RaftStateKey(uint64_t regionID)
{
    return MakeRegionPrefix(regionID, kRaftStateSuffix);
}

static std::vector<uint8_t> ApplyStateKey(uint64_t regionID)
{
    return MakeRegionPrefix(regionID, kApplyStateSuffix);
}

static bool IsRaftStateKey(std::vector<uint8_t> key)
{
    assert(key.size() >= 2);
    return (key.size() == 11 && key[0] == kLocalPrefix[0] && key[1] == kRegionRaftPrefix[0]);
}

static std::pair<uint64_t, std::vector<uint8_t>> DecodeRegionMetaKey(std::vector<uint8_t> key)
{
    if((RegionMetaMinKey.size() + 8 + 1) != (key.size()))
    {
        // TODO: log invalid region meta key length for key
        return std::pair<uint64_t, std::vector<uint8_t>>(0, std::vector<uint8_t>{});
    }
    if( !((key[0] == RegionMetaMinKey[0]) && (key[1] == RegionMetaMinKey[1])) ) {
        // TODO: invalid region meta key prefix for key
        return std::pair<uint64_t, std::vector<uint8_t>>(0, std::vector<uint8_t>{});
    }
    uint64_t regionID = ReadU64(key.begin() + RegionMetaMinKey.size());
}

static std::vector<uint8_t> RegionMetaPrefixKey(uint64_t regionID)
{
    std::vector<uint8_t> packet;
    packet.insert(packet.begin(), kLocalPrefix.begin(), kLocalPrefix.end());
    packet.insert(packet.end(), kRegionMetaPrefix.begin(), kRegionMetaPrefix.end());
    WriteU64(packet, regionID);
    return packet;
}

// kLocalPrefix + kRegionMetaPrefix + regionID + kRegionStateSuffix
static std::vector<uint8_t> RegionStateKey(uint64_t regionID)
{
    std::vector<uint8_t> packet;
    packet.insert(packet.begin(), kLocalPrefix.begin(), kLocalPrefix.end());
    packet.insert(packet.end(), kRegionMetaPrefix.begin(), kRegionMetaPrefix.end());
    WriteU64(packet, regionID);
    packet.insert(packet.end(), kRegionStateSuffix.begin(), kRegionStateSuffix.end());
    return packet;
}

/// RaftLogIndex gets the log index from raft log key generated by RaftLogKey.
static uint64_t RaftLogIndex(std::vector<uint8_t> key)
{
    if(key.size() != kRegionRaftLogLen)
    {
        // log key is not a valid raft log key
        return 0;
    }
    return ReadU64(key.begin() + (kRegionRaftLogLen - 8));
}

static raft_serverpb::RegionLocalState* GetRegionLocalState(std::shared_ptr<rocksdb::DB> db, uint64_t regionId)
{
    raft_serverpb::RegionLocalState* regionLocalState;
    GetMeta(db, std::string(RegionStateKey(regionId).begin(), RegionStateKey(regionId).end()), regionLocalState);
    return regionLocalState;
}

static std::pair<raft_serverpb::RaftLocalState*, rocksdb::Status> GetRaftLocalState(std::shared_ptr<rocksdb::DB> db, uint64_t regionId)
{
    raft_serverpb::RaftLocalState* raftLocalState;
    rocksdb::Status s = GetMeta(db, std::string(RaftStateKey(regionId).begin(), RaftStateKey(regionId).end()), raftLocalState);
    return std::pair<raft_serverpb::RaftLocalState*, rocksdb::Status> (raftLocalState, s);
}

static std::pair<raft_serverpb::RaftApplyState*, rocksdb::Status> GetApplyState(std::shared_ptr<rocksdb::DB> db, uint64_t regionId)
{
    raft_serverpb::RaftApplyState* applyState;
    rocksdb::Status s = GetMeta(db, std::string(ApplyStateKey(regionId).begin(), ApplyStateKey(regionId).end()), applyState);
    return std::pair<raft_serverpb::RaftApplyState*, rocksdb::Status> (applyState, s);   
}

static eraftpb::Entry* GetRaftEntry(std::shared_ptr<rocksdb::DB> db, uint64_t regionId, uint64_t idx)
{
    eraftpb::Entry* entry;
    GetMeta(db, std::string(RaftLogKey(regionId, idx).begin(), RaftLogKey(regionId, idx).end()), entry);
    return entry;
}

const uint8_t kRaftInitLogTerm = 5;
const uint8_t kRaftInitLogIndex = 5;

//
//  This function init raft local state to db
// 
static std::pair<raft_serverpb::RaftLocalState*, bool> InitRaftLocalState(std::shared_ptr<rocksdb::DB> raftEngine, std::shared_ptr<metapb::Region> region)
{
    auto lst = GetRaftLocalState(raftEngine, region->id());
    if(lst.second.IsNotFound()) 
    {
        raft_serverpb::RaftLocalState raftState;
        raftState.set_allocated_hard_state(new eraftpb::HardState);
        // new split region
        if (region->peers().size() > 0)
        {
            raftState.set_last_index(kRaftInitLogIndex);
            raftState.set_last_term(kRaftInitLogTerm);
            raftState.mutable_hard_state()->set_term(kRaftInitLogTerm);
            raftState.mutable_hard_state()->set_commit(kRaftInitLogIndex);
            if(!PutMeta(raftEngine, std::string(RaftStateKey(region->id()).begin(), RaftStateKey(region->id()).end()), raftState))
            {
                return std::pair<raft_serverpb::RaftLocalState*, bool>(&raftState, false);
            }
        }
    }
    return std::pair<raft_serverpb::RaftLocalState*, bool>(lst.first, true);
}

static std::pair<raft_serverpb::RaftApplyState*, bool> InitApplyState(std::shared_ptr<rocksdb::DB> kvEngine, std::shared_ptr<metapb::Region> region)
{
    auto ast = GetApplyState(kvEngine, region->id());
    if(ast.second.IsNotFound()) 
    {
        raft_serverpb::RaftApplyState applyState;
        applyState.set_allocated_truncated_state(new raft_serverpb::RaftTruncatedState);
        if(region->peers().size() > 0)
        {
            applyState.set_applied_index(kRaftInitLogIndex);
            applyState.mutable_truncated_state()->set_index(kRaftInitLogIndex);
            applyState.mutable_truncated_state()->set_term(kRaftInitLogTerm);
        }
        if(!PutMeta(kvEngine, std::string(ApplyStateKey(region->id()).begin(), ApplyStateKey(region->id()).end()), applyState))
        {
            return std::pair<raft_serverpb::RaftApplyState*, bool>(&applyState, false);
        }
    }
    return std::pair<raft_serverpb::RaftApplyState*, bool>(ast.first, false);
}

//
// write region state to kv write batch
//
static void WriteRegionState(std::shared_ptr<rocksdb::WriteBatch> kvWB, std::shared_ptr<metapb::Region> region, const raft_serverpb::PeerState& state)
{
    raft_serverpb::RegionLocalState regionState;
    regionState.set_state(state);
    regionState.set_allocated_region(& *region);
    SetMeta(kvWB, std::string(RegionStateKey(region->id()).begin(), RegionStateKey(region->id()).end()), regionState);
}

} // namespace kvserver

#endif
